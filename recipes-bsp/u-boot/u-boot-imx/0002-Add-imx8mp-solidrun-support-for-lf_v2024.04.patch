From dc6938ea291e859852322d144a70fe79bdfe4647 Mon Sep 17 00:00:00 2001
From: Omar El-Domeiri <github@doesnotexist.com>
Date: Wed, 3 Jul 2024 21:57:17 +0000
Subject: [PATCH] Add imx8mp solidrun support for lf_v2024.04

---
 arch/arm/dts/imx8mp-solidrun-u-boot.dtsi      |  32 +-
 arch/arm/dts/imx8mp-solidrun.dts              | 485 +++--------
 arch/arm/include/asm/mach-imx/sys_proto.h     |   1 +
 arch/arm/mach-imx/imx8m/Kconfig               |   2 +-
 arch/arm/mach-imx/imx8m/soc.c                 |  25 +
 board/solidrun/common/tlv_data.c              | 103 ++-
 board/solidrun/common/tlv_data.h              |  22 +-
 .../imx8mp_solidrun/imx8mp_solidrun.c         | 608 ++++++++-----
 board/solidrun/imx8mp_solidrun/spl.c          | 354 +++++++-
 cmd/Kconfig                                   |   2 +
 cmd/tlv_eeprom.c                              | 796 +-----------------
 configs/imx8mp_solidrun_defconfig             |  30 +-
 drivers/net/dwc_eth_qos.c                     |  13 +
 drivers/net/dwc_eth_qos_imx.c                 |   2 +-
 drivers/net/fec_mxc.c                         |   7 +-
 drivers/net/phy/phy.c                         |   5 +
 include/configs/imx8mp_solidrun.h             |  90 +-
 include/tlv_eeprom.h                          | 119 ++-
 lib/Kconfig                                   |   1 +
 lib/Makefile                                  |   2 +
 lib/tlv/Kconfig                               |  16 +
 lib/tlv/Makefile                              |   5 +
 lib/tlv/tlv_eeprom.c                          | 778 +++++++++++++++++
 23 files changed, 2035 insertions(+), 1466 deletions(-)
 create mode 100644 lib/tlv/Kconfig
 create mode 100644 lib/tlv/Makefile
 create mode 100644 lib/tlv/tlv_eeprom.c

diff --git a/arch/arm/dts/imx8mp-solidrun-u-boot.dtsi b/arch/arm/dts/imx8mp-solidrun-u-boot.dtsi
index 445f45214b0..064a8760128 100644
--- a/arch/arm/dts/imx8mp-solidrun-u-boot.dtsi
+++ b/arch/arm/dts/imx8mp-solidrun-u-boot.dtsi
@@ -86,9 +86,11 @@
 	u-boot,off-on-delay-us = <20000>;
 };
 
-&pinctrl_reg_usdhc2_vmmc {
+
+/* &pinctrl_reg_usdhc2_vmmc {
 	bootph-pre-ram;
 };
+*/
 
 &pinctrl_uart2 {
 	bootph-pre-ram;
@@ -146,13 +148,6 @@
 	bootph-pre-ram;
 };
 
-&usdhc1 {
-	bootph-pre-ram;
-	assigned-clocks = <&clk IMX8MP_CLK_USDHC1>;
-	assigned-clock-rates = <400000000>;
-	assigned-clock-parents = <&clk IMX8MP_SYS_PLL1_400M>;
-};
-
 &usdhc2 {
 	bootph-pre-ram;
 	sd-uhs-sdr104;
@@ -175,20 +170,17 @@
 	bootph-pre-ram;
 };
 
-&ethphy0 {
-	reset-gpios = <&gpio4 22 GPIO_ACTIVE_LOW>;
-	reset-assert-us = <15000>;
-	reset-deassert-us = <100000>;
-};
-
-&fec {
-	phy-reset-gpios = <&gpio4 2 GPIO_ACTIVE_LOW>;
-	phy-reset-duration = <15>;
-	phy-reset-post-delay = <100>;
+&eqos {
+	compatible = "fsl,imx-eqos";
+	/delete-property/ assigned-clocks;
+	/delete-property/ assigned-clock-parents;
+	/delete-property/ assigned-clock-rates;
 };
 
-&flexspi {
-	assigned-clock-parents = <&clk IMX8MP_SYS_PLL1_400M>;
+&lcdif1 {
+	/delete-property/ assigned-clocks;
+	/delete-property/ assigned-clock-parents;
+	/delete-property/ assigned-clock-rates;
 };
 
 &mipi_dsi {
diff --git a/arch/arm/dts/imx8mp-solidrun.dts b/arch/arm/dts/imx8mp-solidrun.dts
index 36b860125e0..d488861532a 100644
--- a/arch/arm/dts/imx8mp-solidrun.dts
+++ b/arch/arm/dts/imx8mp-solidrun.dts
@@ -5,7 +5,6 @@
 
 /dts-v1/;
 
-#include <dt-bindings/phy/phy-imx8-pcie.h>
 #include <dt-bindings/usb/pd.h>
 #include "imx8mp.dtsi"
 
@@ -13,64 +12,43 @@
 	model = "NXP i.MX8MPlus LPDDR4 EVK board";
 	compatible = "fsl,imx8mp-evk", "fsl,imx8mp";
 
+	aliases {
+		ethernet0 = &eqos;
+		ethernet1 = &fec;
+	};
+
 	chosen {
 		bootargs = "console=ttymxc1,115200 earlycon=ec_imx6q,0x30890000,115200";
 		stdout-path = &uart2;
 	};
 
-	gpio-leds {
-		compatible = "gpio-leds";
-		pinctrl-names = "default";
-		pinctrl-0 = <&pinctrl_gpio_led>;
-
-		led-0 {
-			gpios = <&gpio3 16 GPIO_ACTIVE_HIGH>;
-			default-state = "on";
-		};
-	};
-
 	memory@40000000 {
 		device_type = "memory";
 		reg = <0x0 0x40000000 0 0xc0000000>,
 		      <0x1 0x00000000 0 0xc0000000>;
 	};
 
-	pcie0_refclk: pcie0-refclk {
-		compatible = "fixed-clock";
-			#clock-cells = <0>;
-			clock-frequency = <100000000>;
-	};
-
-	reg_can1_stby: regulator-can1-stby {
-		compatible = "regulator-fixed";
-		regulator-name = "can1-stby";
+	/*ned to test first one and see what we want to do with the LEDS*/
+	leds {
+		compatible = "gpio-leds";
 		pinctrl-names = "default";
-		pinctrl-0 = <&pinctrl_flexcan1_reg>;
-		regulator-min-microvolt = <3300000>;
-		regulator-max-microvolt = <3300000>;
-		gpio = <&gpio5 5 GPIO_ACTIVE_HIGH>;
-		enable-active-high;
-	};
+		pinctrl-0 = <&pinctrl_gpio_led>;
 
-	reg_can2_stby: regulator-can2-stby {
-		compatible = "regulator-fixed";
-		regulator-name = "can2-stby";
-		pinctrl-names = "default";
-		pinctrl-0 = <&pinctrl_flexcan2_reg>;
-		regulator-min-microvolt = <3300000>;
-		regulator-max-microvolt = <3300000>;
-		gpio = <&gpio4 27 GPIO_ACTIVE_HIGH>;
-		enable-active-high;
+		status {
+			label = "status";
+			gpios = <&gpio4 22 GPIO_ACTIVE_HIGH>;
+			default-state = "on"; /* LED GREEN */
+		};
 	};
 
-	reg_pcie0: regulator-pcie {
+	reg_usb1_host_vbus: regulator-usb1-vbus {
 		compatible = "regulator-fixed";
+		regulator-name = "usb1_host_vbus";
 		pinctrl-names = "default";
-		pinctrl-0 = <&pinctrl_pcie0_reg>;
-		regulator-name = "MPCIE_3V3";
-		regulator-min-microvolt = <3300000>;
-		regulator-max-microvolt = <3300000>;
-		gpio = <&gpio2 6 GPIO_ACTIVE_HIGH>;
+		pinctrl-0 = <&pinctrl_usb1_vbus>;
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		gpio = <&gpio1 14 GPIO_ACTIVE_HIGH>;
 		enable-active-high;
 		regulator-always-on;
 	};
@@ -78,68 +56,14 @@
 	reg_usdhc2_vmmc: regulator-usdhc2 {
 		compatible = "regulator-fixed";
 		pinctrl-names = "default";
-		pinctrl-0 = <&pinctrl_reg_usdhc2_vmmc>;
+		//pinctrl-0 = <&pinctrl_reg_usdhc2_vmmc>;
 		regulator-name = "VSD_3V3";
 		regulator-min-microvolt = <3300000>;
 		regulator-max-microvolt = <3300000>;
-		gpio = <&gpio2 19 GPIO_ACTIVE_HIGH>;
-		enable-active-high;
-	};
-
-	dsi_host: dsi-host {
-		compatible = "samsung,sec-mipi-dsi";
-		status = "okay";
-	};
-
-	rm67199_panel {
-		compatible = "raydium,rm67199";
-		pinctrl-names = "default";
-		pinctrl-0 = <&pinctrl_mipi_dsi_en>;
-		reset-gpio = <&gpio1 8 GPIO_ACTIVE_LOW>;
-		dsi-lanes = <4>;
-		video-mode = <2>;	/* 0: burst mode
-					 * 1: non-burst mode with sync event
-					 * 2: non-burst mode with sync pulse
-					 */
-		panel-width-mm = <68>;
-		panel-height-mm = <121>;
-		status = "okay";
-
-		port {
-			rm67191_from_dsim: endpoint {
-				remote-endpoint = <&dsim_to_rm67191>;
-			};
-		};
-	};
-
-	cbtl04gp {
-		compatible = "nxp,cbtl04gp";
-		pinctrl-names = "default";
-		pinctrl-0 = <&pinctrl_typec_mux>;
-		switch-gpios = <&gpio4 20 GPIO_ACTIVE_LOW>;
-		orientation-switch;
-
-		port {
-			usb3_data_ss: endpoint {
-				remote-endpoint = <&typec_con_ss>;
-			};
-		};
-	};
-};
-
-&flexspi {
-	pinctrl-names = "default";
-	pinctrl-0 = <&pinctrl_flexspi0>;
-	status = "okay";
-
-	flash0: flash@0 {
-		reg = <0>;
-		#address-cells = <1>;
-		#size-cells = <1>;
-		compatible = "jedec,spi-nor";
-		spi-max-frequency = <80000000>;
-		spi-tx-bus-width = <1>;
-		spi-rx-bus-width = <4>;
+		//gpio = <&gpio2 19 GPIO_ACTIVE_HIGH>;
+		//enable-active-high;
+		startup-delay-us = <100>;
+		off-on-delay-us = <12000>;
 	};
 };
 
@@ -174,9 +98,9 @@
 		#address-cells = <1>;
 		#size-cells = <0>;
 
-		ethphy0: ethernet-phy@1 {
+		ethphy0: ethernet-phy@0 {
 			compatible = "ethernet-phy-ieee802.3-c22";
-			reg = <1>;
+			reg = <0>;
 			eee-broken-1000t;
 			reset-gpios = <&gpio4 22 GPIO_ACTIVE_LOW>;
 			reset-assert-us = <10000>;
@@ -276,21 +200,6 @@
 	};
 };
 
-&flexcan1 {
-	pinctrl-names = "default";
-	pinctrl-0 = <&pinctrl_flexcan1>;
-	xceiver-supply = <&reg_can1_stby>;
-	status = "okay";
-};
-
-&flexcan2 {
-	pinctrl-names = "default";
-	pinctrl-0 = <&pinctrl_flexcan2>;
-	xceiver-supply = <&reg_can2_stby>;
-	pinctrl-assert-gpios = <&pca6416 3 GPIO_ACTIVE_HIGH>;
-	status = "disabled";/* can2 pin conflict with pdm */
-};
-
 &i2c1 {
 	clock-frequency = <400000>;
 	pinctrl-names = "default", "gpio";
@@ -394,6 +303,12 @@
 			};
 		};
 	};
+
+	eeprom: eeprom@50{
+		compatible = "st,24c01", "atmel,24c01";
+		reg = <0x50>;
+		pagesize = <16>;
+	};
 };
 
 &i2c2 {
@@ -407,7 +322,7 @@
 
 	adv_bridge: adv7535@3d {
 		compatible = "adi,adv7535";
-		reg = <0x3d>;
+		reg = <0x39>;
 		adi,addr-cec = <0x3c>;
 		adi,dsi-lanes = <4>;
 		status = "okay";
@@ -418,46 +333,6 @@
 			};
 		};
 	};
-
-	ptn5110: tcpc@50 {
-		compatible = "nxp,ptn5110";
-		pinctrl-names = "default";
-		pinctrl-0 = <&pinctrl_typec>;
-		reg = <0x50>;
-		interrupt-parent = <&gpio4>;
-		interrupts = <19 8>;
-
-		port {
-			typec_dr_sw: endpoint {
-				remote-endpoint = <&usb3_drd_sw>;
-			};
-		};
-
-		usb_con: connector {
-			compatible = "usb-c-connector";
-			label = "USB-C";
-			power-role = "dual";
-			data-role = "dual";
-			try-power-role = "sink";
-			source-pdos = <PDO_FIXED(5000, 3000, PDO_FIXED_USB_COMM)>;
-			sink-pdos = <PDO_FIXED(5000, 3000, PDO_FIXED_USB_COMM)
-				     PDO_VAR(5000, 20000, 3000)>;
-			op-sink-microwatt = <15000000>;
-			self-powered;
-
-			ports {
-				#address-cells = <1>;
-				#size-cells = <0>;
-
-				port@1 {
-					reg = <1>;
-					typec_con_ss: endpoint {
-						remote-endpoint = <&usb3_data_ss>;
-					};
-				};
-			};
-		};
-	};
 };
 
 &i2c3 {
@@ -474,44 +349,13 @@
 		reg = <0x20>;
 		gpio-controller;
 		#gpio-cells = <2>;
-		interrupt-controller;
-		#interrupt-cells = <2>;
-		pinctrl-names = "default";
-		pinctrl-0 = <&pinctrl_pca6416_int>;
-		interrupt-parent = <&gpio1>;
-		interrupts = <12 IRQ_TYPE_LEVEL_LOW>;
-		gpio-line-names = "EXT_PWREN1",
-			"EXT_PWREN2",
-			"CAN1/I2C5_SEL",
-			"PDM/CAN2_SEL",
-			"FAN_EN",
-			"PWR_MEAS_IO1",
-			"PWR_MEAS_IO2",
-			"EXP_P0_7",
-			"EXP_P1_0",
-			"EXP_P1_1",
-			"EXP_P1_2",
-			"EXP_P1_3",
-			"EXP_P1_4",
-			"EXP_P1_5",
-			"EXP_P1_6",
-			"EXP_P1_7";
 	};
-};
 
-/* I2C on expansion connector J22. */
-&i2c5 {
-	clock-frequency = <100000>; /* Lower clock speed for external bus. */
-	pinctrl-names = "default";
-	pinctrl-0 = <&pinctrl_i2c5>;
-	status = "disabled"; /* can1 pins conflict with i2c5 */
-
-	/* GPIO 2 of PCA6416 is used to switch between CAN1 and I2C5 functions:
-	 *     LOW:  CAN1 (default, pull-down)
-	 *     HIGH: I2C5
-	 * You need to set it to high to enable I2C5 (for example, add gpio-hog
-	 * in pca6416 node).
-	 */
+	eeprom_carrier: eeprom@57 {
+		compatible = "st,24c02", "atmel,24c02";
+		reg = <0x57>;
+		pagesize = <8>;
+	};
 };
 
 &lcdif1 {
@@ -527,37 +371,9 @@
 				remote-endpoint = <&adv7535_from_dsim>;
 			};
 		};
-
-		port@2 {
-			dsim_to_rm67191: endpoint {
-				remote-endpoint = <&rm67191_from_dsim>;
-			};
-		};
 	};
 };
 
-&pcie_phy {
-	fsl,refclk-pad-mode = <IMX8_PCIE_REFCLK_PAD_INPUT>;
-	clocks = <&pcie0_refclk>;
-	clock-names = "ref";
-	status = "okay";
-};
-
-&pcie {
-	pinctrl-names = "default";
-	pinctrl-0 = <&pinctrl_pcie0>;
-	reset-gpio = <&gpio2 7 GPIO_ACTIVE_LOW>;
-	clocks = <&clk IMX8MP_CLK_HSIO_ROOT>,
-		 <&clk IMX8MP_CLK_PCIE_ROOT>,
-		 <&clk IMX8MP_CLK_HSIO_AXI>;
-	clock-names = "pcie", "pcie_aux", "pcie_bus";
-	assigned-clocks = <&clk IMX8MP_CLK_PCIE_AUX>;
-	assigned-clock-rates = <10000000>;
-	assigned-clock-parents = <&clk IMX8MP_SYS_PLL2_50M>;
-	vpcie-supply = <&reg_pcie0>;
-	status = "okay";
-};
-
 &snvs_pwrkey {
 	status = "okay";
 };
@@ -569,16 +385,6 @@
 	status = "okay";
 };
 
-&usb3_phy0 {
-	fsl,phy-tx-vref-tune = <0xe>;
-	fsl,phy-tx-preemp-amp-tune = <3>;
-	fsl,phy-tx-vboost-level = <5>;
-	fsl,phy-comp-dis-tune = <7>;
-	fsl,pcs-tx-deemph-3p5db = <0x21>;
-	fsl,phy-pcs-tx-swing-full = <0x7f>;
-	status = "okay";
-};
-
 &usb3_0 {
 	status = "okay";
 };
@@ -589,31 +395,15 @@
 	srp-disable;
 	adp-disable;
 	usb-role-switch;
-	role-switch-default-mode = "none";
-	snps,dis-u1-entry-quirk;
-	snps,dis-u2-entry-quirk;
 	status = "okay";
-
-	port {
-		usb3_drd_sw: endpoint {
-			remote-endpoint = <&typec_dr_sw>;
-		};
-	};
 };
 
-&usb3_phy1 {
-	fsl,phy-tx-preemp-amp-tune = <3>;
-	fsl,phy-tx-vref-tune = <0xb>;
-	status = "okay";
-};
-
-&usb3_1 {
+&usb_dwc3_1 {
+	dr_mode = "host";
 	status = "okay";
 };
 
 &usb_dwc3_1 {
-	pinctrl-names = "default";
-	pinctrl-0 = <&pinctrl_usb1_vbus>;
 	dr_mode = "host";
 	status = "okay";
 };
@@ -653,67 +443,41 @@
 &iomuxc {
 	pinctrl_eqos: eqosgrp {
 		fsl,pins = <
-			MX8MP_IOMUXC_ENET_MDC__ENET_QOS_MDC				0x2
-			MX8MP_IOMUXC_ENET_MDIO__ENET_QOS_MDIO				0x2
-			MX8MP_IOMUXC_ENET_RD0__ENET_QOS_RGMII_RD0			0x90
-			MX8MP_IOMUXC_ENET_RD1__ENET_QOS_RGMII_RD1			0x90
-			MX8MP_IOMUXC_ENET_RD2__ENET_QOS_RGMII_RD2			0x90
-			MX8MP_IOMUXC_ENET_RD3__ENET_QOS_RGMII_RD3			0x90
-			MX8MP_IOMUXC_ENET_RXC__CCM_ENET_QOS_CLOCK_GENERATE_RX_CLK	0x90
-			MX8MP_IOMUXC_ENET_RX_CTL__ENET_QOS_RGMII_RX_CTL			0x90
-			MX8MP_IOMUXC_ENET_TD0__ENET_QOS_RGMII_TD0			0x16
-			MX8MP_IOMUXC_ENET_TD1__ENET_QOS_RGMII_TD1			0x16
-			MX8MP_IOMUXC_ENET_TD2__ENET_QOS_RGMII_TD2			0x16
-			MX8MP_IOMUXC_ENET_TD3__ENET_QOS_RGMII_TD3			0x16
-			MX8MP_IOMUXC_ENET_TX_CTL__ENET_QOS_RGMII_TX_CTL			0x16
-			MX8MP_IOMUXC_ENET_TXC__CCM_ENET_QOS_CLOCK_GENERATE_TX_CLK	0x16
-			MX8MP_IOMUXC_SAI2_RXC__GPIO4_IO22				0x10
+			MX8MP_IOMUXC_ENET_MDC__ENET_QOS_MDC					0x3
+			MX8MP_IOMUXC_ENET_MDIO__ENET_QOS_MDIO				0x3
+			MX8MP_IOMUXC_ENET_RD0__ENET_QOS_RGMII_RD0			0x91
+			MX8MP_IOMUXC_ENET_RD1__ENET_QOS_RGMII_RD1			0x91
+			MX8MP_IOMUXC_ENET_RD2__ENET_QOS_RGMII_RD2			0x91
+			MX8MP_IOMUXC_ENET_RD3__ENET_QOS_RGMII_RD3			0x91
+			MX8MP_IOMUXC_ENET_RXC__CCM_ENET_QOS_CLOCK_GENERATE_RX_CLK	0x91
+			MX8MP_IOMUXC_ENET_RX_CTL__ENET_QOS_RGMII_RX_CTL			0x91
+			MX8MP_IOMUXC_ENET_TD0__ENET_QOS_RGMII_TD0			0x1f
+			MX8MP_IOMUXC_ENET_TD1__ENET_QOS_RGMII_TD1			0x1f
+			MX8MP_IOMUXC_ENET_TD2__ENET_QOS_RGMII_TD2			0x1f
+			MX8MP_IOMUXC_ENET_TD3__ENET_QOS_RGMII_TD3			0x1f
+			MX8MP_IOMUXC_ENET_TX_CTL__ENET_QOS_RGMII_TX_CTL			0x1f
+			MX8MP_IOMUXC_ENET_TXC__CCM_ENET_QOS_CLOCK_GENERATE_TX_CLK	0x1f
+			MX8MP_IOMUXC_SAI1_TXD7__GPIO4_IO19					0x34
 		>;
 	};
 
 	pinctrl_fec: fecgrp {
 		fsl,pins = <
-			MX8MP_IOMUXC_SAI1_RXD2__ENET1_MDC		0x2
-			MX8MP_IOMUXC_SAI1_RXD3__ENET1_MDIO		0x2
-			MX8MP_IOMUXC_SAI1_RXD4__ENET1_RGMII_RD0		0x90
-			MX8MP_IOMUXC_SAI1_RXD5__ENET1_RGMII_RD1		0x90
-			MX8MP_IOMUXC_SAI1_RXD6__ENET1_RGMII_RD2		0x90
-			MX8MP_IOMUXC_SAI1_RXD7__ENET1_RGMII_RD3		0x90
-			MX8MP_IOMUXC_SAI1_TXC__ENET1_RGMII_RXC		0x90
-			MX8MP_IOMUXC_SAI1_TXFS__ENET1_RGMII_RX_CTL	0x90
-			MX8MP_IOMUXC_SAI1_TXD0__ENET1_RGMII_TD0		0x16
-			MX8MP_IOMUXC_SAI1_TXD1__ENET1_RGMII_TD1		0x16
-			MX8MP_IOMUXC_SAI1_TXD2__ENET1_RGMII_TD2		0x16
-			MX8MP_IOMUXC_SAI1_TXD3__ENET1_RGMII_TD3		0x16
-			MX8MP_IOMUXC_SAI1_TXD4__ENET1_RGMII_TX_CTL	0x16
-			MX8MP_IOMUXC_SAI1_TXD5__ENET1_RGMII_TXC		0x16
-			MX8MP_IOMUXC_SAI1_RXD0__GPIO4_IO02		0x10
-		>;
-	};
-
-	pinctrl_flexcan1: flexcan1grp {
-		fsl,pins = <
-			MX8MP_IOMUXC_SPDIF_RX__CAN1_RX          0x154
-			MX8MP_IOMUXC_SPDIF_TX__CAN1_TX          0x154
-		>;
-	};
-
-	pinctrl_flexcan2: flexcan2grp {
-		fsl,pins = <
-			MX8MP_IOMUXC_SAI5_MCLK__CAN2_RX         0x154
-			MX8MP_IOMUXC_SAI5_RXD3__CAN2_TX         0x154
-		>;
-	};
-
-	pinctrl_flexcan1_reg: flexcan1reggrp {
-		fsl,pins = <
-			MX8MP_IOMUXC_SPDIF_EXT_CLK__GPIO5_IO05  0x154   /* CAN1_STBY */
-		>;
-	};
-
-	pinctrl_flexcan2_reg: flexcan2reggrp {
-		fsl,pins = <
-			MX8MP_IOMUXC_SAI2_MCLK__GPIO4_IO27      0x154   /* CAN2_STBY */
+			MX8MP_IOMUXC_SAI1_RXD2__ENET1_MDC		0x3
+			MX8MP_IOMUXC_SAI1_RXD3__ENET1_MDIO		0x3
+			MX8MP_IOMUXC_SAI1_RXD4__ENET1_RGMII_RD0		0x91
+			MX8MP_IOMUXC_SAI1_RXD5__ENET1_RGMII_RD1		0x91
+			MX8MP_IOMUXC_SAI1_RXD6__ENET1_RGMII_RD2		0x91
+			MX8MP_IOMUXC_SAI1_RXD7__ENET1_RGMII_RD3		0x91
+			MX8MP_IOMUXC_SAI1_TXC__ENET1_RGMII_RXC		0x91
+			MX8MP_IOMUXC_SAI1_TXFS__ENET1_RGMII_RX_CTL	0x91
+			MX8MP_IOMUXC_SAI1_TXD0__ENET1_RGMII_TD0		0x1f
+			MX8MP_IOMUXC_SAI1_TXD1__ENET1_RGMII_TD1		0x1f
+			MX8MP_IOMUXC_SAI1_TXD2__ENET1_RGMII_TD2		0x1f
+			MX8MP_IOMUXC_SAI1_TXD3__ENET1_RGMII_TD3		0x1f
+			MX8MP_IOMUXC_SAI1_TXD4__ENET1_RGMII_TX_CTL	0x1f
+			MX8MP_IOMUXC_SAI1_TXD5__ENET1_RGMII_TXC		0x1f
+			MX8MP_IOMUXC_SAI1_RXD0__GPIO4_IO02		0x34
 		>;
 	};
 
@@ -730,35 +494,32 @@
 
 	pinctrl_gpio_led: gpioledgrp {
 		fsl,pins = <
-			MX8MP_IOMUXC_NAND_READY_B__GPIO3_IO16	0x140
+			MX8MP_IOMUXC_SAI2_RXC__GPIO4_IO22	0x19
+			MX8MP_IOMUXC_SAI2_RXFS__GPIO4_IO21	0x19
+			MX8MP_IOMUXC_SAI2_RXD0__GPIO4_IO23	0x19
+			MX8MP_IOMUXC_SAI2_TXFS__GPIO4_IO24	0x19
+			MX8MP_IOMUXC_UART4_RXD__GPIO5_IO28	0x19
 		>;
 	};
 
 	pinctrl_i2c1: i2c1grp {
 		fsl,pins = <
-			MX8MP_IOMUXC_I2C1_SCL__I2C1_SCL		0x400001c2
-			MX8MP_IOMUXC_I2C1_SDA__I2C1_SDA		0x400001c2
+			MX8MP_IOMUXC_I2C1_SCL__I2C1_SCL		0x400001c3
+			MX8MP_IOMUXC_I2C1_SDA__I2C1_SDA		0x400001c3
 		>;
 	};
 
 	pinctrl_i2c2: i2c2grp {
 		fsl,pins = <
-			MX8MP_IOMUXC_I2C2_SCL__I2C2_SCL		0x400001c2
-			MX8MP_IOMUXC_I2C2_SDA__I2C2_SDA		0x400001c2
+			MX8MP_IOMUXC_I2C2_SCL__I2C2_SCL		0x400001c3
+			MX8MP_IOMUXC_I2C2_SDA__I2C2_SDA		0x400001c3
 		>;
 	};
 
 	pinctrl_i2c3: i2c3grp {
 		fsl,pins = <
-			MX8MP_IOMUXC_I2C3_SCL__I2C3_SCL		0x400001c2
-			MX8MP_IOMUXC_I2C3_SDA__I2C3_SDA		0x400001c2
-		>;
-	};
-
-	pinctrl_i2c5: i2c5grp {
-		fsl,pins = <
-			MX8MP_IOMUXC_SPDIF_RX__I2C5_SDA         0x400001c2
-			MX8MP_IOMUXC_SPDIF_TX__I2C5_SCL         0x400001c2
+			MX8MP_IOMUXC_I2C3_SCL__I2C3_SCL		0x400001c3
+			MX8MP_IOMUXC_I2C3_SDA__I2C3_SDA		0x400001c3
 		>;
 	};
 
@@ -768,38 +529,18 @@
 		>;
 	};
 
-	pinctrl_pcie0: pcie0grp {
+	pinctrl_pmic: pmicirq {
 		fsl,pins = <
-			MX8MP_IOMUXC_I2C4_SCL__PCIE_CLKREQ_B	0x60 /* open drain, pull up */
-			MX8MP_IOMUXC_SD1_DATA5__GPIO2_IO07	0x40
-			MX8MP_IOMUXC_I2C4_SDA__GPIO5_IO21	0x1c4
+			MX8MP_IOMUXC_GPIO1_IO03__GPIO1_IO03	0x41
 		>;
 	};
 
-	pinctrl_pcie0_reg: pcie0reggrp {
+/*	pinctrl_reg_usdhc2_vmmc: regusdhc2vmmcgrp {
 		fsl,pins = <
-			MX8MP_IOMUXC_SD1_DATA4__GPIO2_IO06	0x40
+			MX8MP_IOMUXC_SD2_RESET_B__GPIO2_IO19	0x41
 		>;
 	};
-
-	pinctrl_pmic: pmicirqgrp {
-		fsl,pins = <
-			MX8MP_IOMUXC_GPIO1_IO03__GPIO1_IO03	0x000001c0
-		>;
-	};
-
-	pinctrl_pca6416_int: pca6416_int_grp {
-		fsl,pins = <
-			MX8MP_IOMUXC_GPIO1_IO12__GPIO1_IO12	0x146 /* Input pull-up. */
-		>;
-	};
-
-	pinctrl_reg_usdhc2_vmmc: regusdhc2vmmcgrp {
-		fsl,pins = <
-			MX8MP_IOMUXC_SD2_RESET_B__GPIO2_IO19	0x40
-		>;
-	};
-
+*/
 	pinctrl_i2c1_gpio: i2c1gpiogrp {
 		fsl,pins = <
 			MX8MP_IOMUXC_I2C1_SCL__GPIO5_IO14        	0x1c3
@@ -821,12 +562,6 @@
 		>;
 	};
 
-	pinctrl_typec: typec1grp {
-		fsl,pins = <
-			MX8MP_IOMUXC_SAI1_TXD7__GPIO4_IO19	0x1c4
-		>;
-	};
-
 	pinctrl_typec_mux: typec1muxgrp {
 		fsl,pins = <
 			MX8MP_IOMUXC_SAI1_MCLK__GPIO4_IO20	0x16
@@ -835,63 +570,63 @@
 
 	pinctrl_uart2: uart2grp {
 		fsl,pins = <
-			MX8MP_IOMUXC_UART2_RXD__UART2_DCE_RX	0x140
-			MX8MP_IOMUXC_UART2_TXD__UART2_DCE_TX	0x140
+			MX8MP_IOMUXC_UART2_RXD__UART2_DCE_RX	0x49
+			MX8MP_IOMUXC_UART2_TXD__UART2_DCE_TX	0x49
 		>;
 	};
 
 	pinctrl_usb1_vbus: usb1grp {
 		fsl,pins = <
-			MX8MP_IOMUXC_GPIO1_IO14__USB2_PWR		0x10
+			MX8MP_IOMUXC_GPIO1_IO14__USB2_PWR		0x19
 		>;
 	};
 
 	pinctrl_usdhc2: usdhc2grp {
 		fsl,pins = <
-			MX8MP_IOMUXC_SD2_CLK__USDHC2_CLK	0x190
-			MX8MP_IOMUXC_SD2_CMD__USDHC2_CMD	0x1d0
+			MX8MP_IOMUXC_SD2_CLK__USDHC2_CLK		0x190
+			MX8MP_IOMUXC_SD2_CMD__USDHC2_CMD		0x1d0
 			MX8MP_IOMUXC_SD2_DATA0__USDHC2_DATA0	0x1d0
 			MX8MP_IOMUXC_SD2_DATA1__USDHC2_DATA1	0x1d0
 			MX8MP_IOMUXC_SD2_DATA2__USDHC2_DATA2	0x1d0
 			MX8MP_IOMUXC_SD2_DATA3__USDHC2_DATA3	0x1d0
-			MX8MP_IOMUXC_GPIO1_IO04__USDHC2_VSELECT	0xc0
+			MX8MP_IOMUXC_GPIO1_IO04__USDHC2_VSELECT	0xc1
 		>;
 	};
 
 	pinctrl_usdhc2_100mhz: usdhc2-100mhzgrp {
 		fsl,pins = <
-			MX8MP_IOMUXC_SD2_CLK__USDHC2_CLK	0x194
-			MX8MP_IOMUXC_SD2_CMD__USDHC2_CMD	0x1d4
+			MX8MP_IOMUXC_SD2_CLK__USDHC2_CLK		0x194
+			MX8MP_IOMUXC_SD2_CMD__USDHC2_CMD		0x1d4
 			MX8MP_IOMUXC_SD2_DATA0__USDHC2_DATA0	0x1d4
 			MX8MP_IOMUXC_SD2_DATA1__USDHC2_DATA1	0x1d4
 			MX8MP_IOMUXC_SD2_DATA2__USDHC2_DATA2	0x1d4
 			MX8MP_IOMUXC_SD2_DATA3__USDHC2_DATA3	0x1d4
-			MX8MP_IOMUXC_GPIO1_IO04__USDHC2_VSELECT 0xc0
+			MX8MP_IOMUXC_GPIO1_IO04__USDHC2_VSELECT 0xc1
 		>;
 	};
 
 	pinctrl_usdhc2_200mhz: usdhc2-200mhzgrp {
 		fsl,pins = <
-			MX8MP_IOMUXC_SD2_CLK__USDHC2_CLK	0x196
-			MX8MP_IOMUXC_SD2_CMD__USDHC2_CMD	0x1d6
+			MX8MP_IOMUXC_SD2_CLK__USDHC2_CLK		0x196
+			MX8MP_IOMUXC_SD2_CMD__USDHC2_CMD		0x1d6
 			MX8MP_IOMUXC_SD2_DATA0__USDHC2_DATA0	0x1d6
 			MX8MP_IOMUXC_SD2_DATA1__USDHC2_DATA1	0x1d6
 			MX8MP_IOMUXC_SD2_DATA2__USDHC2_DATA2	0x1d6
 			MX8MP_IOMUXC_SD2_DATA3__USDHC2_DATA3	0x1d6
-			MX8MP_IOMUXC_GPIO1_IO04__USDHC2_VSELECT 0xc0
+			MX8MP_IOMUXC_GPIO1_IO04__USDHC2_VSELECT 0xc1
 		>;
 	};
 
 	pinctrl_usdhc2_gpio: usdhc2gpiogrp {
 		fsl,pins = <
-			MX8MP_IOMUXC_SD2_CD_B__GPIO2_IO12	0x1c4
+			MX8MP_IOMUXC_SD2_CD_B__GPIO2_IO12		0x1c4
 		>;
 	};
 
 	pinctrl_usdhc3: usdhc3grp {
 		fsl,pins = <
-			MX8MP_IOMUXC_NAND_WE_B__USDHC3_CLK	0x190
-			MX8MP_IOMUXC_NAND_WP_B__USDHC3_CMD	0x1d0
+			MX8MP_IOMUXC_NAND_WE_B__USDHC3_CLK		0x190
+			MX8MP_IOMUXC_NAND_WP_B__USDHC3_CMD		0x1d0
 			MX8MP_IOMUXC_NAND_DATA04__USDHC3_DATA0	0x1d0
 			MX8MP_IOMUXC_NAND_DATA05__USDHC3_DATA1	0x1d0
 			MX8MP_IOMUXC_NAND_DATA06__USDHC3_DATA2	0x1d0
@@ -899,15 +634,15 @@
 			MX8MP_IOMUXC_NAND_RE_B__USDHC3_DATA4	0x1d0
 			MX8MP_IOMUXC_NAND_CE2_B__USDHC3_DATA5	0x1d0
 			MX8MP_IOMUXC_NAND_CE3_B__USDHC3_DATA6	0x1d0
-			MX8MP_IOMUXC_NAND_CLE__USDHC3_DATA7	0x1d0
+			MX8MP_IOMUXC_NAND_CLE__USDHC3_DATA7		0x1d0
 			MX8MP_IOMUXC_NAND_CE1_B__USDHC3_STROBE	0x190
 		>;
 	};
 
 	pinctrl_usdhc3_100mhz: usdhc3-100mhzgrp {
 		fsl,pins = <
-			MX8MP_IOMUXC_NAND_WE_B__USDHC3_CLK	0x194
-			MX8MP_IOMUXC_NAND_WP_B__USDHC3_CMD	0x1d4
+			MX8MP_IOMUXC_NAND_WE_B__USDHC3_CLK		0x194
+			MX8MP_IOMUXC_NAND_WP_B__USDHC3_CMD		0x1d4
 			MX8MP_IOMUXC_NAND_DATA04__USDHC3_DATA0	0x1d4
 			MX8MP_IOMUXC_NAND_DATA05__USDHC3_DATA1	0x1d4
 			MX8MP_IOMUXC_NAND_DATA06__USDHC3_DATA2	0x1d4
@@ -915,15 +650,15 @@
 			MX8MP_IOMUXC_NAND_RE_B__USDHC3_DATA4	0x1d4
 			MX8MP_IOMUXC_NAND_CE2_B__USDHC3_DATA5	0x1d4
 			MX8MP_IOMUXC_NAND_CE3_B__USDHC3_DATA6	0x1d4
-			MX8MP_IOMUXC_NAND_CLE__USDHC3_DATA7	0x1d4
+			MX8MP_IOMUXC_NAND_CLE__USDHC3_DATA7		0x1d4
 			MX8MP_IOMUXC_NAND_CE1_B__USDHC3_STROBE	0x194
 		>;
 	};
 
 	pinctrl_usdhc3_200mhz: usdhc3-200mhzgrp {
 		fsl,pins = <
-			MX8MP_IOMUXC_NAND_WE_B__USDHC3_CLK	0x196
-			MX8MP_IOMUXC_NAND_WP_B__USDHC3_CMD	0x1d6
+			MX8MP_IOMUXC_NAND_WE_B__USDHC3_CLK		0x196
+			MX8MP_IOMUXC_NAND_WP_B__USDHC3_CMD		0x1d6
 			MX8MP_IOMUXC_NAND_DATA04__USDHC3_DATA0	0x1d6
 			MX8MP_IOMUXC_NAND_DATA05__USDHC3_DATA1	0x1d6
 			MX8MP_IOMUXC_NAND_DATA06__USDHC3_DATA2	0x1d6
@@ -931,14 +666,14 @@
 			MX8MP_IOMUXC_NAND_RE_B__USDHC3_DATA4	0x1d6
 			MX8MP_IOMUXC_NAND_CE2_B__USDHC3_DATA5	0x1d6
 			MX8MP_IOMUXC_NAND_CE3_B__USDHC3_DATA6	0x1d6
-			MX8MP_IOMUXC_NAND_CLE__USDHC3_DATA7	0x1d6
+			MX8MP_IOMUXC_NAND_CLE__USDHC3_DATA7		0x1d6
 			MX8MP_IOMUXC_NAND_CE1_B__USDHC3_STROBE	0x196
 		>;
 	};
 
 	pinctrl_wdog: wdoggrp {
 		fsl,pins = <
-			MX8MP_IOMUXC_GPIO1_IO02__WDOG1_WDOG_B	0x166
+			MX8MP_IOMUXC_GPIO1_IO02__WDOG1_WDOG_B	0xc6
 		>;
 	};
 };
diff --git a/arch/arm/include/asm/mach-imx/sys_proto.h b/arch/arm/include/asm/mach-imx/sys_proto.h
index dc589e03cec..8f801ed26bd 100644
--- a/arch/arm/include/asm/mach-imx/sys_proto.h
+++ b/arch/arm/include/asm/mach-imx/sys_proto.h
@@ -347,6 +347,7 @@ unsigned long call_imx_sip_ret2(unsigned long id, unsigned long reg0,
 				unsigned long reg3);
 
 void imx_get_mac_from_fuse(int dev_id, unsigned char *mac);
+int board_get_mac(int dev_id, unsigned char *mac);
 
 #if defined(CONFIG_MX6) || defined(CONFIG_MX7) || defined(CONFIG_MX7ULP)
 void enable_ca7_smp(void);
diff --git a/arch/arm/mach-imx/imx8m/Kconfig b/arch/arm/mach-imx/imx8m/Kconfig
index bbc2a345502..798df8be977 100644
--- a/arch/arm/mach-imx/imx8m/Kconfig
+++ b/arch/arm/mach-imx/imx8m/Kconfig
@@ -338,13 +338,13 @@ config TARGET_IMX8MP_DDR4_EVK
 
 config TARGET_IMX8MP_SOLIDRUN
 	bool "SolidRun MX8M Plus SOM based products"
-
 	select IMX8MP
 	select SUPPORT_SPL
 	select IMX8M_LPDDR4
 	select FSL_CAAM
 	select FSL_BLOB
 	select ARCH_MISC_INIT
+	select EEPROM_TLV_LIB
 	select SPL_CRYPTO if SPL
 
 config TARGET_PICO_IMX8MQ
diff --git a/arch/arm/mach-imx/imx8m/soc.c b/arch/arm/mach-imx/imx8m/soc.c
index c3282ccc213..34cde0bbf46 100644
--- a/arch/arm/mach-imx/imx8m/soc.c
+++ b/arch/arm/mach-imx/imx8m/soc.c
@@ -252,6 +252,19 @@ __weak int board_phys_sdram_size(phys_size_t *size)
 	return 0;
 }
 
+__weak int board_phys_sdram2_size(phys_size_t *size)
+{
+	if (!size)
+		return -EINVAL;
+
+#ifdef PHYS_SDRAM_2_SIZE
+	*size = PHYS_SDRAM_2_SIZE;
+#else
+	*size = 0;
+#endif
+	return 0;
+}
+
 int dram_init(void)
 {
 	phys_size_t sdram_size;
@@ -267,6 +280,12 @@ int dram_init(void)
 	else
 		gd->ram_size = sdram_size;
 
+	ret = board_phys_sdram2_size(&sdram_size);
+	if (ret)
+		return ret;
+
+	gd->ram_size += sdram_size;
+
 	return 0;
 }
 
@@ -310,6 +329,12 @@ int dram_init_banksize(void)
 		gd->bd->bi_dram[bank].size = sdram_b1_size;
 	}
 
+#ifdef PHYS_SDRAM_2_SIZE
+	ret = board_phys_sdram2_size(&sdram_b2_size);
+	if(ret)
+		return ret;
+#endif
+
 	if (sdram_b2_size) {
 		if (++bank >= CONFIG_NR_DRAM_BANKS) {
 			puts("CONFIG_NR_DRAM_BANKS is not enough for SDRAM_2\n");
diff --git a/board/solidrun/common/tlv_data.c b/board/solidrun/common/tlv_data.c
index cf5824886c3..b54ee74333c 100644
--- a/board/solidrun/common/tlv_data.c
+++ b/board/solidrun/common/tlv_data.c
@@ -8,31 +8,55 @@
 #include <tlv_eeprom.h>
 #include "tlv_data.h"
 
-#define SR_TLV_CODE_RAM_SIZE	0x81
-
 static void store_product_name(struct tlvinfo_tlv *tlv_entry,
-			       struct tlv_data *td)
+			       struct tlv_data *td, int index)
 {
 	int len;
 	char *dest;
 
-	if (strlen(td->tlv_product_name[0]) == 0)
-		dest = td->tlv_product_name[0];
-	else if (strlen(td->tlv_product_name[1]) == 0)
-		dest = td->tlv_product_name[1];
-	else
-		return;
+	dest = td->tlv_product_name[index];
+	len = min_t(unsigned int, tlv_entry->length,
+		    sizeof(td->tlv_product_name[index]) - 1);
+	memcpy(dest, tlv_entry->value, len);
+}
+
+static void store_part_number(struct tlvinfo_tlv *tlv_entry,
+			      struct tlv_data *td, int index)
+{
+	int len;
+	char *dest;
+
+	dest = td->tlv_part_number[index];
 
 	len = min_t(unsigned int, tlv_entry->length,
-		    sizeof(td->tlv_product_name[0]) - 1);
+		    sizeof(td->tlv_part_number[index]) - 1);
 	memcpy(dest, tlv_entry->value, len);
 }
 
+static void store_mac_size(struct tlvinfo_tlv *tlv_entry,
+			   struct tlv_data *td, int index)
+{
+	td->tlv_mac_count[index] = (tlv_entry->value[0] << 8) | tlv_entry->value[1];
+	pr_debug("%s: read mac count = %u\n", __func__, td->tlv_mac_count[index]);
+}
+
+static void store_mac_base(struct tlvinfo_tlv *tlv_entry,
+			   struct tlv_data *td, int index)
+{
+	char *dest;
+
+	dest = td->tlv_mac_base[index];
+	memcpy(dest, tlv_entry->value, 6);
+	pr_debug("%s: read mac base = %02X:%02X:%02X:%02X:%02X:%02X\n", __func__, dest[0], dest[1], dest[2], dest[3], dest[4], dest[5]);
+}
+
 static void parse_tlv_vendor_ext(struct tlvinfo_tlv *tlv_entry,
-				 struct tlv_data *td)
+				 struct tlv_data *td, int index)
 {
 	u8 *val = tlv_entry->value;
 	u32 pen; /* IANA Private Enterprise Numbers */
+	int len;
+	char *dest;
 
 	if (tlv_entry->length < 5) /* 4 bytes PEN + at least 1 byte type */
 		return;
@@ -43,20 +67,36 @@ static void parse_tlv_vendor_ext(struct tlvinfo_tlv *tlv_entry,
 	if (pen != 0xffffffff)
 		return;
 
-	if (val[4] != SR_TLV_CODE_RAM_SIZE)
-		return;
-	if (tlv_entry->length < 6)
-		return;
-	td->ram_size = val[5];
-
-	/* extension with additional data field for number of ddr channels */
-	if (tlv_entry->length >= 7) {
-		td->ram_channels = val[6];
-	}
+	switch (val[4]) {
+	case SR_TLV_CODE_RAM_SIZE:
+		if (tlv_entry->length < 6)
+			break;
+		td->ram_size = val[5];
+
+ 		/* extenvsion with additional data field for number of ddr channels */
+ 		if (tlv_entry->length >= 7) {
+ 			td->ram_channels = val[6];
+ 		}
+		break;
+	case SR_TLV_CODE_KIT_NUMBER:
+		if (tlv_entry->length > 257)
+			break;
+		dest = td->tlv_kit_number[index];
+		len = tlv_entry->length - 5;
+		len = min_t(unsigned int, tlv_entry->length - 5,
+					sizeof(td->tlv_kit_number[index]) - 1);
+		memcpy(dest, &tlv_entry->value[5], len);
+		dest[len] = '\0';
+		break;
+	default:
+		break;
+	};
+		
+	return;
 }
 
 static void parse_tlv_data(u8 *eeprom, struct tlvinfo_header *hdr,
-			   struct tlvinfo_tlv *entry, struct tlv_data *td)
+			   struct tlvinfo_tlv *entry, struct tlv_data *td, int index)
 {
 	unsigned int tlv_offset, tlv_len;
 
@@ -67,10 +107,19 @@ static void parse_tlv_data(u8 *eeprom, struct tlvinfo_header *hdr,
 
 		switch (entry->type) {
 		case TLV_CODE_PRODUCT_NAME:
-			store_product_name(entry, td);
+			store_product_name(entry, td, index);
+			break;
+		case TLV_CODE_PART_NUMBER:
+			store_part_number(entry, td, index);
+			break;
+		case TLV_CODE_MAC_SIZE:
+			store_mac_size(entry, td, index);
+			break;
+		case TLV_CODE_MAC_BASE:
+			store_mac_base(entry, td, index);
 			break;
 		case TLV_CODE_VENDOR_EXT:
-			parse_tlv_vendor_ext(entry, td);
+			parse_tlv_vendor_ext(entry, td, index);
 			break;
 		default:
 			break;
@@ -87,12 +136,12 @@ void read_tlv_data(struct tlv_data *td)
 	struct tlvinfo_tlv *tlv_entry;
 	int ret, i;
 
-	for (i = 0; i < 2; i++) {
+	for (i = 0; i < TLV_MAX_DEVICES; i++) {
 		ret = read_tlvinfo_tlv_eeprom(eeprom_data, &tlv_hdr,
 					      &tlv_entry, i);
 		if (ret < 0)
 			continue;
-		parse_tlv_data(eeprom_data, tlv_hdr, tlv_entry, td);
+		parse_tlv_data(eeprom_data, tlv_hdr, tlv_entry, td, i);
 	}
 }
 
@@ -105,4 +154,4 @@ bool sr_product_is(const struct tlv_data *td, const char *product)
 		return true;
 
 	return false;
-}
+}
\ No newline at end of file
diff --git a/board/solidrun/common/tlv_data.h b/board/solidrun/common/tlv_data.h
index be3f782ac4a..484245e3074 100644
--- a/board/solidrun/common/tlv_data.h
+++ b/board/solidrun/common/tlv_data.h
@@ -8,11 +8,31 @@
 
 struct tlv_data {
 	/* Store product name of both SOM and carrier */
-	char tlv_product_name[2][32];
+	char tlv_product_name[TLV_MAX_DEVICES][32];
+	char tlv_part_number[TLV_MAX_DEVICES][257];
+	char tlv_kit_number[TLV_MAX_DEVICES][257];
+	unsigned char tlv_mac_base[TLV_MAX_DEVICES][6];
+	u16 tlv_mac_count[TLV_MAX_DEVICES];
 	unsigned int ram_size;
 	uint8_t ram_channels;
 };
 
+/*
+ * SolidRun TLV vendor extension data format
+ * (compatible with format used on Armada 388 Clearfog by Baruch Siach)
+ */
+struct __attribute__((__packed__)) sr_tlv_ext {
+	u32 pen; // IANA Private Enterprise Number
+	u8 code; // identification code for data
+	u8 data[];
+};
+
+// SolidRun TLV vendor extension data codes
+enum sr_tlv_code {
+	SR_TLV_CODE_KIT_NUMBER  = 0x10,
+	SR_TLV_CODE_RAM_SIZE    = 0x81,
+};
+
 void read_tlv_data(struct tlv_data *td);
 bool sr_product_is(const struct tlv_data *td, const char *product);
 
diff --git a/board/solidrun/imx8mp_solidrun/imx8mp_solidrun.c b/board/solidrun/imx8mp_solidrun/imx8mp_solidrun.c
index 9fa9b4c8071..b905c7c87e0 100644
--- a/board/solidrun/imx8mp_solidrun/imx8mp_solidrun.c
+++ b/board/solidrun/imx8mp_solidrun/imx8mp_solidrun.c
@@ -16,6 +16,7 @@
 #include <asm-generic/gpio.h>
 #include <asm/arch/imx8mp_pins.h>
 #include <asm/arch/clock.h>
+#include <asm/arch/ddr.h>:
 #include <asm/arch/sys_proto.h>
 #include <asm/mach-imx/gpio.h>
 #include <asm/mach-imx/mxc_i2c.h>
@@ -25,7 +26,26 @@
 #include "../common/tcpc.h"
 #include <usb.h>
 #include <dwc3-uboot.h>
+#include <imx_sip.h>
+#include <linux/arm-smccc.h>
 #include <mmc.h>
+#include <env.h>
+#include <tlv_eeprom.h>
+#include "../common/tlv_data.h"
+
+#define ONE_GB 0x40000000ULL
+
+static struct tlv_data hb_tlv_data;
+static bool tlv_read_once;
+
+static void hb_read_tlv_data(void)
+{
+        if (tlv_read_once)
+                return;
+        tlv_read_once = true;
+
+        read_tlv_data(&hb_tlv_data);
+}
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -53,7 +73,7 @@ static void setup_gpmi_nand(void)
 struct efi_fw_image fw_images[] = {
 	{
 		.image_type_id = IMX_BOOT_IMAGE_GUID,
-		.fw_name = u"IMX8MP-EVK-RAW",
+		.fw_name = u"IMX8MP-SR-RAW",
 		.image_index = 1,
 	},
 };
@@ -66,6 +86,144 @@ struct efi_capsule_update_info update_info = {
 
 #endif /* EFI_HAVE_CAPSULE_SUPPORT */
 
+static struct board_id {
+	char carrier_name[32];
+	char carrier_rev[3];
+	char som_name[8];
+	char som_rev[3];
+	char product_name[32];
+	char product_rev[3];
+} board_id = {0};
+
+int check_mirror_ddr_tmp(unsigned int addr_1, unsigned int addr_2)
+{
+	/* return 1 if mirror detected between addr_1 and addre_2, else return 0*/
+	int retrain_tmp;
+	unsigned int save1, save2, mirror;
+	volatile unsigned int *ptr;
+
+	retrain_tmp = 0;
+	ptr = (volatile unsigned int *)CFG_SYS_SDRAM_BASE;
+	save1 = ptr[addr_1];
+	save2 = ptr[addr_2];
+	ptr[addr_2] = save1 << 1;
+	ptr[addr_1] = ~save1;
+	mirror = ptr[addr_2];
+	if (mirror == ~save1) {
+		retrain_tmp = 1;
+	}
+	ptr[addr_1] = save1;
+	ptr[addr_2] = save2;
+
+	// Check if mirror have detected
+	if (retrain_tmp == 1)
+		return 1;
+
+	return 0;
+}
+
+__weak unsigned int lpddr4_mr_read(unsigned int mr_rank, unsigned int mr_addr)
+{
+	unsigned int tmp;
+
+	reg32_write(DRC_PERF_MON_MRR0_DAT(0), 0x1);
+
+	do {
+		tmp = reg32_read(DDRC_MRSTAT(0));
+	} while (tmp & 0x1);
+
+	reg32_write(DDRC_MRCTRL0(0), (mr_rank << 4) | 0x1);
+	reg32_write(DDRC_MRCTRL1(0), (mr_addr << 8));
+	reg32setbit(DDRC_MRCTRL0(0), 31);
+	do {
+		tmp = reg32_read(DRC_PERF_MON_MRR0_DAT(0));
+	} while ((tmp & 0x8) == 0);
+	tmp = reg32_read(DRC_PERF_MON_MRR1_DAT(0));
+	reg32_write(DRC_PERF_MON_MRR0_DAT(0), 0x4);
+
+	while (tmp) { //try to find a significant byte in the word
+		if (tmp & 0xff) {
+			tmp &= 0xff;
+			break;
+		}
+		tmp >>= 8;
+	}
+
+	return tmp;
+}
+
+int board_phys_sdram_size(phys_size_t *size)
+{
+	if (!size)
+		return -EINVAL;
+
+	// Check Mirror for 1GB
+	if (check_mirror_ddr_tmp(0, ONE_GB/4)) {
+		*size = ONE_GB;
+		return 0;
+	}
+	// Check Mirror for 2GB
+	if (check_mirror_ddr_tmp(0, 2*ONE_GB/4)) {
+		*size = 2*ONE_GB;
+		return 0;
+	}
+
+	// Default size 3GByte
+	*size = 3*ONE_GB;
+	return 0;
+}
+
+
+int board_phys_sdram2_size(phys_size_t *size)
+{
+	phys_size_t output = 0;
+	unsigned int mr5, mr8;
+	int ret;
+
+	ret = board_phys_sdram_size(size);
+	if (ret)
+		return ret;
+
+	/* 4G configuration are Samsung/Micron.
+	 * If SDRAM1 size is 3G, there are 3 options:
+	 *
+	 * (*) A 3G Micron chip.
+	 * (*) 4G Micron/Samsung
+	 * (*) 8G Micron
+	 *
+	 */
+
+	if (*size != 3*ONE_GB)
+		goto exit;
+
+	/* Read LPDDr MR5 register, if MAN. ID is Samsung, this is a 4G Samsung DDR */
+	mr5 = lpddr4_mr_read(0xF, 0x5);
+	if (mr5 == LPDDR4_SAMSUNG_MANID) {
+		output = ONE_GB;
+		goto exit;
+	}
+
+	/* At this point, this is either:
+	 * - 3G Micron
+	 * - 4G Micron
+	 * - 8G Micron
+	 * Can be determined based on MR8.
+	 * If MR8 = 0x10, then the density is 16Gb per die (8Gb per channel),
+	 * Since the Micron 4G is dual die, this means 32Gb => 4GB
+	 * If MR8 = 0x18, then density is 16Gb per die, single channel,
+	 * since Micron 8G is quad die, this means 64Gb => 8GB
+	 */
+	mr8 = lpddr4_mr_read(0xF, 0x8);
+	if (mr8 == 0x10)
+		output = ONE_GB;
+	else if (mr8 == 0x18)
+		output = 5*ONE_GB;
+
+exit:
+	*size = output;
+	return 0;
+}
+
 int board_early_init_f(void)
 {
 	struct wdog_regs *wdog = (struct wdog_regs *)WDOG1_BASE_ADDR;
@@ -85,17 +243,6 @@ int board_early_init_f(void)
 int ft_board_setup(void *blob, struct bd_info *bd)
 {
 #ifdef CONFIG_IMX8M_DRAM_INLINE_ECC
-#ifdef CONFIG_TARGET_IMX8MP_DDR4_EVK
-	int rc;
-	phys_addr_t ecc_start = 0x120000000;
-	size_t ecc_size = 0x20000000;
-
-	rc = add_res_mem_dt_node(blob, "ecc", ecc_start, ecc_size);
-	if (rc < 0) {
-		printf("Could not create ecc reserved-memory node.\n");
-		return rc;
-	}
-#else
 	int rc;
 	phys_addr_t ecc0_start = 0xb0000000;
 	phys_addr_t ecc1_start = 0x130000000;
@@ -119,156 +266,12 @@ int ft_board_setup(void *blob, struct bd_info *bd)
 		printf("Could not create ecc2 reserved-memory node.\n");
 		return rc;
 	}
-#endif
 #endif
 
 	return 0;
 }
 #endif
 
-#ifdef CONFIG_USB_TCPC
-struct tcpc_port port1;
-struct tcpc_port port2;
-
-static int setup_pd_switch(uint8_t i2c_bus, uint8_t addr)
-{
-	struct udevice *bus;
-	struct udevice *i2c_dev = NULL;
-	int ret;
-	uint8_t valb;
-
-	ret = uclass_get_device_by_seq(UCLASS_I2C, i2c_bus, &bus);
-	if (ret) {
-		printf("%s: Can't find bus\n", __func__);
-		return -EINVAL;
-	}
-
-	ret = dm_i2c_probe(bus, addr, 0, &i2c_dev);
-	if (ret) {
-		printf("%s: Can't find device id=0x%x\n",
-			__func__, addr);
-		return -ENODEV;
-	}
-
-	ret = dm_i2c_read(i2c_dev, 0xB, &valb, 1);
-	if (ret) {
-		printf("%s dm_i2c_read failed, err %d\n", __func__, ret);
-		return -EIO;
-	}
-	valb |= 0x4; /* Set DB_EXIT to exit dead battery mode */
-	ret = dm_i2c_write(i2c_dev, 0xB, (const uint8_t *)&valb, 1);
-	if (ret) {
-		printf("%s dm_i2c_write failed, err %d\n", __func__, ret);
-		return -EIO;
-	}
-
-	/* Set OVP threshold to 23V */
-	valb = 0x6;
-	ret = dm_i2c_write(i2c_dev, 0x8, (const uint8_t *)&valb, 1);
-	if (ret) {
-		printf("%s dm_i2c_write failed, err %d\n", __func__, ret);
-		return -EIO;
-	}
-
-	return 0;
-}
-
-int pd_switch_snk_enable(struct tcpc_port *port)
-{
-	if (port == &port1) {
-		debug("Setup pd switch on port 1\n");
-		return setup_pd_switch(1, 0x72);
-	} else
-		return -EINVAL;
-}
-
-/* Port2 is the power supply, port 1 does not support power */
-struct tcpc_port_config port1_config = {
-	.i2c_bus = 1, /*i2c2*/
-	.addr = 0x50,
-	.port_type = TYPEC_PORT_UFP,
-	.max_snk_mv = 20000,
-	.max_snk_ma = 3000,
-	.max_snk_mw = 45000,
-	.op_snk_mv = 15000,
-	.switch_setup_func = &pd_switch_snk_enable,
-	.disable_pd = true,
-};
-
-struct tcpc_port_config port2_config = {
-	.i2c_bus = 2, /*i2c3*/
-	.addr = 0x50,
-	.port_type = TYPEC_PORT_UFP,
-	.max_snk_mv = 20000,
-	.max_snk_ma = 3000,
-	.max_snk_mw = 45000,
-	.op_snk_mv = 15000,
-};
-
-#define USB_TYPEC_SEL IMX_GPIO_NR(4, 20)
-#define USB_TYPEC_EN IMX_GPIO_NR(2, 20)
-
-static iomux_v3_cfg_t ss_mux_gpio[] = {
-	MX8MP_PAD_SAI1_MCLK__GPIO4_IO20 | MUX_PAD_CTRL(NO_PAD_CTRL),
-	MX8MP_PAD_SD2_WP__GPIO2_IO20 | MUX_PAD_CTRL(NO_PAD_CTRL),
-};
-
-void ss_mux_select(enum typec_cc_polarity pol)
-{
-	if (pol == TYPEC_POLARITY_CC1)
-		gpio_direction_output(USB_TYPEC_SEL, 0);
-	else
-		gpio_direction_output(USB_TYPEC_SEL, 1);
-}
-
-static int setup_typec(void)
-{
-	int ret;
-	struct gpio_desc per_12v_desc;
-
-	debug("tcpc_init port 2\n");
-	ret = tcpc_init(&port2, port2_config, NULL);
-	if (ret) {
-		printf("%s: tcpc port2 init failed, err=%d\n",
-		       __func__, ret);
-	} else if (tcpc_pd_sink_check_charging(&port2)) {
-		printf("Power supply on USB2\n");
-
-		/* Enable PER 12V, any check before it? */
-		ret = dm_gpio_lookup_name("gpio@20_1", &per_12v_desc);
-		if (ret) {
-			printf("%s lookup gpio@20_1 failed ret = %d\n", __func__, ret);
-			return -ENODEV;
-		}
-
-		ret = dm_gpio_request(&per_12v_desc, "per_12v_en");
-		if (ret) {
-			printf("%s request per_12v failed ret = %d\n", __func__, ret);
-			return -EIO;
-		}
-
-		/* Enable PER 12V regulator */
-		dm_gpio_set_dir_flags(&per_12v_desc, GPIOD_IS_OUT | GPIOD_IS_OUT_ACTIVE);
-	}
-
-	debug("tcpc_init port 1\n");
-	imx_iomux_v3_setup_multiple_pads(ss_mux_gpio, ARRAY_SIZE(ss_mux_gpio));
-	gpio_request(USB_TYPEC_SEL, "typec_sel");
-	gpio_request(USB_TYPEC_EN, "typec_en");
-	gpio_direction_output(USB_TYPEC_EN, 0);
-
-	ret = tcpc_init(&port1, port1_config, &ss_mux_select);
-	if (ret) {
-		printf("%s: tcpc port1 init failed, err=%d\n",
-		       __func__, ret);
-	} else {
-		return ret;
-	}
-
-	return ret;
-}
-#endif
-
 #ifdef CONFIG_USB_DWC3
 
 #define USB_PHY_CTRL0			0xF0040
@@ -353,20 +356,15 @@ static void dwc3_nxp_usb_phy_init(struct dwc3_device *dwc3)
 int board_usb_init(int index, enum usb_init_type init)
 {
 	int ret = 0;
+	// OMAR: Solidrun diverges from imx8mp_evk.c here because:
+	// solidrun calls imx8mp_usb_power outside of the conditional
+	// imx8m_usb_power(index, true);
 
 	if (index == 0 && init == USB_INIT_DEVICE) {
 		imx8m_usb_power(index, true);
-#ifdef CONFIG_USB_TCPC
-		ret = tcpc_setup_ufp_mode(&port1);
-		if (ret)
-			return ret;
-#endif
 		dwc3_nxp_usb_phy_init(&dwc3_device_data);
 		return dwc3_uboot_init(&dwc3_device_data);
 	} else if (index == 0 && init == USB_INIT_HOST) {
-#ifdef CONFIG_USB_TCPC
-		ret = tcpc_setup_dfp_mode(&port1);
-#endif
 		return ret;
 	}
 
@@ -379,45 +377,51 @@ int board_usb_cleanup(int index, enum usb_init_type init)
 	if (index == 0 && init == USB_INIT_DEVICE) {
 		dwc3_uboot_exit(index);
 		imx8m_usb_power(index, false);
-	} else if (index == 0 && init == USB_INIT_HOST) {
-#ifdef CONFIG_USB_TCPC
-		ret = tcpc_disable_src_vbus(&port1);
-#endif
 	}
 
+	imx8m_usb_power(index, false);
+
 	return ret;
 }
 
-#ifdef CONFIG_USB_TCPC
-/* Not used so far */
-int board_typec_get_mode(int index)
+#endif
+
+static void setup_fec(void)
 {
-	int ret = 0;
-	enum typec_cc_polarity pol;
-	enum typec_cc_state state;
+	struct iomuxc_gpr_base_regs *gpr =
+		(struct iomuxc_gpr_base_regs *)IOMUXC_GPR_BASE_ADDR;
 
-	if (index == 0) {
-		tcpc_setup_ufp_mode(&port1);
+	/* Enable RGMII TX clk output */
+	setbits_le32(&gpr->gpr[1], BIT(22));
+}
 
-		ret = tcpc_get_cc_status(&port1, &pol, &state);
-		if (!ret) {
-			if (state == TYPEC_STATE_SRC_RD_RA || state == TYPEC_STATE_SRC_RD)
-				return USB_INIT_HOST;
-		}
+static int setup_eqos(void)
+{
+	struct iomuxc_gpr_base_regs *gpr =
+		(struct iomuxc_gpr_base_regs *)IOMUXC_GPR_BASE_ADDR;
 
-		return USB_INIT_DEVICE;
-	} else {
-		return USB_INIT_HOST;
-	}
+	/* set INTF as RGMII, enable RGMII TXC clock */
+	clrsetbits_le32(&gpr->gpr[1],
+			IOMUXC_GPR_GPR1_GPR_ENET_QOS_INTF_SEL_MASK, BIT(16));
+	setbits_le32(&gpr->gpr[1], BIT(19) | BIT(21));
+
+	return set_clk_eqos(ENET_125MHZ);
 }
-#endif
-#endif
+
+#define DISPMIX				13
+#define MIPI				15
 
 int board_init(void)
 {
-#ifdef CONFIG_USB_TCPC
-	setup_typec();
-#endif
+	struct arm_smccc_res res;
+
+	if (CONFIG_IS_ENABLED(FEC_MXC)) {
+		setup_fec();
+	}
+
+	if (CONFIG_IS_ENABLED(DWC_ETH_QOS)) {
+		setup_eqos();
+	}
 
 #ifdef CONFIG_NAND_MXS
 	setup_gpmi_nand();
@@ -427,22 +431,242 @@ int board_init(void)
 	init_usb_clk();
 #endif
 
+	/* enable the dispmix & mipi phy power domain */
+	arm_smccc_smc(IMX_SIP_GPC, IMX_SIP_GPC_PM_DOMAIN,
+		      DISPMIX, true, 0, 0, 0, 0, &res);
+	arm_smccc_smc(IMX_SIP_GPC, IMX_SIP_GPC_PM_DOMAIN,
+		      MIPI, true, 0, 0, 0, 0, &res);
+
 	return 0;
 }
 
+static bool find_i2c_dev(u8 i2c_bus, u8 address) {
+	struct udevice *bus;
+	struct udevice *i2c_dev = NULL;
+	int ret;
+
+	ret = uclass_get_device_by_seq(UCLASS_I2C, i2c_bus, &bus);
+	if (ret) {
+		pr_err("%s: failed to get i2c bus %u: %i\n", __func__, i2c_bus, ret);
+		return false;
+	}
+
+	ret = dm_i2c_probe(bus, address, 0, &i2c_dev);
+	if (ret) {
+		return false;
+	}
+
+	return true;
+}
+
+/*
+ * Identify board from TLV EEPROM - store result in board_id:
+ * - carrier_name: name of carrier
+ * - carrier_rev: revision of carrier
+ * - som_name: name of SoC
+ * - som_rev: revision of SoM
+ */
+static void board_id_from_tlv_info(void) {
+	char *tmp;
+
+	for(int i = 0; i < TLV_MAX_DEVICES; i++) {
+		// parse sku - processor or carrier indicated at index 2-6
+		if(memcmp(&hb_tlv_data.tlv_part_number[i][2], "HBC", 3) == 0) {
+			// HummingBoard
+			switch(hb_tlv_data.tlv_part_number[i][5]) {
+			    case 'M': // Mate
+				tmp = "mate";
+				break;
+			    case 'R': // Ripple
+				tmp = "ripple";
+				break;
+			    case 'U': // Pulse or Extended
+				tmp = "pulse";
+				if (hb_tlv_data.tlv_part_number[i][7] == 'X')
+					tmp = "extended";
+				break;
+			    default:
+				pr_err("%s: did not recognise board variant '%c' in sku \"%s\"!\n", __func__, hb_tlv_data.tlv_part_number[i][5], hb_tlv_data.tlv_part_number[i]);
+				tmp = 0;
+			}
+
+			if(tmp) {
+				if(snprintf(board_id.carrier_name, sizeof(board_id.carrier_name), "hummingboard-%s", tmp) >= sizeof(board_id.carrier_name)) {
+					pr_err("%s: buffer too small, carrier_name skipped!\n", __func__);
+					board_id.carrier_name[0] = 0;
+				}
+			}
+
+			// board revision at index 12-13
+			if(hb_tlv_data.tlv_part_number[i][12] && hb_tlv_data.tlv_part_number[i][13]) {
+				board_id.carrier_rev[0] = hb_tlv_data.tlv_part_number[i][12];
+				board_id.carrier_rev[1] = hb_tlv_data.tlv_part_number[i][13];
+				board_id.carrier_rev[2] = 0;
+			} else {
+			    pr_err("%s: did not find board revision in sku \"%s\"!\n", __func__, hb_tlv_data.tlv_part_number[i]);
+			}
+		} else if(memcmp(&hb_tlv_data.tlv_part_number[i][2], "MP8", 3) == 0) {
+			// i.MX8MP SoM
+			strcpy(board_id.som_name, "imx8mp");
+
+			// variant
+			switch(hb_tlv_data.tlv_part_number[i][5]) {
+			    case 'D':
+				break;
+			    case 'Q':
+				break;
+			    default:
+				pr_err("%s: did not recognise cpu variant '%c' in sku \"%s\"!\n", __func__, hb_tlv_data.tlv_part_number[i][5], hb_tlv_data.tlv_part_number[i]);
+			}
+
+			// SoM revision at index 19-20
+			if(hb_tlv_data.tlv_part_number[i][19] && hb_tlv_data.tlv_part_number[i][20]) {
+				board_id.som_rev[0] = hb_tlv_data.tlv_part_number[i][19];
+				board_id.som_rev[1] = hb_tlv_data.tlv_part_number[i][20];
+				board_id.som_rev[2] = 0;
+			} else {
+			    pr_err("%s: did not find som revision in sku \"%s\"!\n", __func__, hb_tlv_data.tlv_part_number[i]);
+			}
+		} else {
+			pr_err("%s: did not recognise SKU %s!\n", __func__, hb_tlv_data.tlv_part_number[i]);
+		}
+
+		pr_info("%s: read kit sku %s\n", __func__, hb_tlv_data.tlv_kit_number[i]);
+
+		// SRMP8QDW00D01GE008X01CE
+		if(!hb_tlv_data.tlv_kit_number[i][0])
+			continue;
+		else if (strlen(hb_tlv_data.tlv_kit_number[i]) != 23) {
+			pr_err("%s: kit sku \"%s\" has wrong length (expecting %0X)\n", __func__, hb_tlv_data.tlv_kit_number[i], 23);
+			continue;
+		}
+
+		// kit type
+		switch(hb_tlv_data.tlv_kit_number[i][18]) {
+		    case 'M': // Mate
+			tmp = "hummingboard-mate";
+			break;
+		    case 'U': // Pulse
+			tmp = "hummingboard-pulse";
+			break;
+		    case 'R': // Ripple
+			tmp = "hummingboard-ripple";
+			break;
+		    case 'X': // CuBox
+			tmp = "cubox-m";
+			break;
+		    default:
+			tmp = 0;
+			pr_err("%s: did not recognise kit variant '%c' in sku \"%s\"!\n", __func__, hb_tlv_data.tlv_kit_number[i][18], hb_tlv_data.tlv_kit_number[i]);
+		}
+		if(tmp) {
+			if(board_id.product_name[0] && strcmp(board_id.product_name, tmp) != 0) {
+				pr_err("%s: components mixed between kits, found %s and %s!\n", __func__, board_id.product_name, tmp);
+			}
+			strcpy(board_id.product_name, tmp);
+		}
+
+		// kit revision
+		board_id.product_rev[0] = hb_tlv_data.tlv_kit_number[i][19];
+		board_id.product_rev[1] = hb_tlv_data.tlv_kit_number[i][20];
+		board_id.product_rev[2] = 0;
+	}
+}
+
 int board_late_init(void)
 {
+	char fdtfile[48] = {0};
 #ifdef CONFIG_ENV_IS_IN_MMC
 	board_late_mmc_env_init();
 #endif
+
+	// populate tlv_data
+	hb_read_tlv_data();
+
+	// identify device
+	board_id_from_tlv_info();
+
+	// fall-back when identification fails
+	if(!board_id.carrier_name[0]) {
+		// could be HummingBoard or CuBox ...
+		if(board_id.product_name[0] && strcmp(board_id.product_name, "cubox-m") == 0) {
+			// we have a kit and it's a CuBox
+			printf("%s: SoM is part of a CuBox-M Kit, infering that carrier is CuBox-M!\n", __func__);
+			strcpy(board_id.carrier_name, board_id.product_name);
+		}
+		else if(find_i2c_dev(2, 0x57)) {
+			// if EEPROM exists, it must be HummingBoard
+			printf("%s: could not identify board, defaulting to HummingBoard Pulse Revision 2.5!\n", __func__);
+			strcpy(board_id.carrier_name, "hummingboard-pulse");
+			strcpy(board_id.carrier_rev, "25");
+		} else {
+			// likely a CuBox
+			printf("%s: could not identify board, defaulting to CuBox-M!\n", __func__);
+			strcpy(board_id.carrier_name, "cubox-m");
+		}
+	}
+	if(!board_id.som_name[0]) {
+		// could be anything ...
+		printf("%s: could not identify som, defaulting to i.MX8M Plus Revision 1.1!\n", __func__);
+		strcpy(board_id.som_name, "imx8mp");
+		strcpy(board_id.som_rev, "11");
+	}
+
+	// auto-select device-tree
+	if (!env_get("fdtfile")) {
+		// OMAR: TODO determine which version is correct
+		// if(snprintf(fdtfile, sizeof(fdtfile), "freescale/%s-%s.dtb", board_id.som_name, board_id.carrier_name) >= sizeof(fdtfile)) {
+		if(snprintf(fdtfile, sizeof(fdtfile), "%s-%s.dtb", board_id.som_name, board_id.carrier_name) >= sizeof(fdtfile)) {
+			pr_err("%s: buffer too small, fdtfile truncated!\n", __func__);
+		}
+		env_set("fdtfile", fdtfile);
+	} else {
+		printf("%s: fdtfile set in environment, keeping as is.\n", __func__);
+	}
+
 #ifdef CONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG
-	env_set("board_name", "EVK");
-	env_set("board_rev", "iMX8MP");
+	// expose identity to environment
+	if(board_id.carrier_name[0])
+		env_set("carrier_name", board_id.carrier_name);
+	if(board_id.carrier_rev[0])
+		env_set("carrier_rev", board_id.carrier_rev);
+	if(board_id.som_name[0])
+		env_set("som_name", board_id.som_name);
+	if(board_id.som_rev[0])
+		env_set("som_rev", board_id.som_rev);
+	if(board_id.product_name[0])
+		env_set("product_name", board_id.product_name);
+	if(board_id.product_rev[0])
+		env_set("product_rev", board_id.product_rev);
 #endif
 
 	return 0;
 }
 
+/*
+ * select board mac address for given interface
+ */
+int board_get_mac(int dev_id, unsigned char *mac) {
+	char macenv[16] = {0};
+	mac[0] = 0;
+
+	/*
+	 * Note: Environment ethaddr (eth1addr, eth2addr, ...) has first priority,
+	 * therefore it should be read and returned here.
+	 * However the fec driver will write the result from this function to the environment,
+	 * causing a feedback loop.
+	 */
+
+	// fuses
+	imx_get_mac_from_fuse(dev_id, mac);
+	if(is_valid_ethaddr(mac)) {
+		printf("%s: interface %i: using mac from fuses: %02X:%02X:%02X:%02X:%02X:%02X\n", __func__, dev_id, mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
+		return 0;
+	}
+
+	return -ENOENT;
+}
+
 #ifdef CONFIG_ANDROID_SUPPORT
 bool is_power_key_pressed(void) {
 	return (bool)(!!(readl(SNVS_HPSR) & (0x1 << 6)));
diff --git a/board/solidrun/imx8mp_solidrun/spl.c b/board/solidrun/imx8mp_solidrun/spl.c
index b7b21f0b490..0321ba8a2fc 100644
--- a/board/solidrun/imx8mp_solidrun/spl.c
+++ b/board/solidrun/imx8mp_solidrun/spl.c
@@ -29,6 +29,8 @@
 #include <asm/arch/ddr.h>
 #include <asm/sections.h>
 
+#include "lpddr_timing.h"
+
 DECLARE_GLOBAL_DATA_PTR;
 
 int spl_board_boot_device(enum boot_device boot_dev_spl)
@@ -57,9 +59,341 @@ int spl_board_boot_device(enum boot_device boot_dev_spl)
 #endif
 }
 
+#ifdef PRINT_DDR_TABLES
+static struct dram_timing_info *const dram_timing_patch(struct dram_timing_info *const timings)
+{
+	if (timings == &dram_timing_patch_2gb_samsung) {
+		timing_patch_apply(&dram_timing_1gb_samsung_micron, timings);
+		return &dram_timing_1gb_samsung_micron;
+	}
+	if (timings == &dram_timing_patch_8gb_micron) {
+		timing_patch_apply(&dram_timing_4gb_samsung_micron, timings);
+		return &dram_timing_4gb_samsung_micron;
+	}
+	return timings;
+}
+
+static struct dram_configs {
+	const char *const label;
+	struct dram_timing_info *const timings;
+	unsigned int mr5, mr6, mr7, mr8;
+	bool is_valid;
+} confs[] = {
+	{ .label = "Samsung 8G       ", .timings = &dram_timing_patch_8gb_micron },
+	{ .label = "Samsung/Micron 4G", .timings = &dram_timing_4gb_samsung_micron },
+	{ .label = "Micron 3G        ", .timings = &dram_timing_3gb_micron },
+	{ .label = "Samsung 2G       ", .timings = &dram_timing_patch_2gb_samsung },
+	{ .label = "Samsung/Micron 1G", .timings = &dram_timing_1gb_samsung_micron },
+};
+
+static void spl_print_ddr_tables(void)
+{
+	int ret, i;
+
+	/* Collect data */
+	for (i = 0; i < ARRAY_SIZE(confs); i++) {
+		ret = ddr_init(dram_timing_patch(confs[i].timings));
+		dram_timing_patch(confs[i].timings);
+		if (ret) {
+			confs[i].is_valid = false;
+		} else {
+			confs[i].is_valid = true;
+			confs[i].mr5 = lpddr4_mr_read(0xFF, 0x5);
+			confs[i].mr6 = lpddr4_mr_read(0xFF, 0x6);
+			confs[i].mr7 = lpddr4_mr_read(0xFF, 0x7);
+			confs[i].mr8 = lpddr4_mr_read(0xFF, 0x8);
+		}
+	}
+
+	/* Now print table */
+
+	printf("\n\n\n");
+	printf("****************************************\n");
+	printf("************** DDR Tables **************\n");
+	printf("****************************************\n");
+	printf("(Please print the tables multiple times\nto determine if the values are stable).\n");
+	printf("\n");
+	printf("Size\tMR5\tMR6\tMR7\tMR8\n");
+
+	for (i = 0; i < ARRAY_SIZE(confs); i++) {
+		if (!confs[i].is_valid)
+			printf("%-17s\t********** Failed **********\n", confs[i].label);
+		else
+			printf("%-17s\t0x%x\t0x%x\t0x%x\t0x%x\n", confs[i].label, confs[i].mr5, confs[i].mr6, confs[i].mr7, confs[i].mr8);
+	}
+	printf("\n");
+	printf("****************************************\n");
+	printf("************ DDR Tables End ************\n");
+	printf("****************************************\n");
+	printf("\n\n\n");
+}
+#endif //PRINT_DDR_TABLES
+
+/* MUST be called after DDR training with 4G parameters! */
+static bool spl_dram_is_3G(void)
+{
+	volatile uint32_t *base;
+	uint32_t backup;
+	bool ret = false;
+
+	/* SDRAM 2 starts after 3G.
+	 * We write 512M after the 3G offset.
+	 * If the value is not written, this is a 3G configuration.
+	 */
+	base = (volatile uint32_t *)(PHYS_SDRAM_2 + SZ_512M);
+
+	/* Backup value */
+	backup = *base;
+
+	/* Write something */
+	*base = ~backup;
+	/* Read back */
+	if (*base != ~backup)
+		ret = true;
+
+	*base = backup;
+	return ret;
+}
+
+/* MUST be called after DDR training with 2G parameters! */
+static bool spl_dram_is_1G(void)
+{
+	volatile uint32_t *base1, *base2;
+	volatile uint32_t tmp;
+	uint32_t backup1, backup2;
+	bool ret = false;
+
+	/* The idea is to write a value in offset 1G and see if it is
+	 * written in offset 0 as well
+	 */
+	base1 = (volatile uint32_t *)CFG_SYS_SDRAM_BASE;
+	base2 = (volatile uint32_t *)((uint64_t)CFG_SYS_SDRAM_BASE + SZ_1G);
+
+	backup1 = *base1;
+	backup2 = *base2;
+
+	*base2 = 0xAAAAAAAA;
+	*base1 = 0x55555555;
+
+	tmp = *base2;
+	if (tmp == 0x55555555)
+		ret = true;
+
+	*base1 = backup1;
+	*base2 = backup2;
+
+	return ret;
+}
+
+static bool spl_generic_ddr_init(void)
+{
+	int ret;
+	bool output = true;
+
+	/* Try 8GB Micron. */
+	timing_patch_apply(&dram_timing_4gb_samsung_micron, &dram_timing_patch_8gb_micron);
+	ret = ddr_init(&dram_timing_4gb_samsung_micron);
+	timing_patch_apply(&dram_timing_4gb_samsung_micron, &dram_timing_patch_8gb_micron);
+	if (!ret) {
+		printf("DDR 8G Micron identified!\n");
+		goto exit;
+	}
+
+	/* Try 4G Samsung.
+	 * Will work with: 3G Micron as well.
+	 */
+	ret = ddr_init(&dram_timing_4gb_samsung_micron);
+	if (!ret) {
+		if (!spl_dram_is_3G()) {
+			printf("DDR 4G Samsung/Micron identified!\n");
+			goto exit;
+		}
+	}
+
+	/* Try 3G Micron.
+	 * Will work with: 4G Samsung/Micron, but since we already tested it,
+	 * it's not relevant
+	 */
+	ret = ddr_init(&dram_timing_3gb_micron);
+	if (!ret) {
+		printf("DDR 3G Micron identified!\n");
+		goto exit;
+	}
+
+	/* Try 2G Samsung.
+	 * Will work with: 1G Samsung as well.
+	 */
+	timing_patch_apply(&dram_timing_1gb_samsung_micron, &dram_timing_patch_2gb_samsung);
+	ret = ddr_init(&dram_timing_1gb_samsung_micron);
+	timing_patch_apply(&dram_timing_1gb_samsung_micron, &dram_timing_patch_2gb_samsung);
+	if (!ret) {
+		if (!spl_dram_is_1G()) {
+			printf("DDR 2G Samsung identified!\n");
+			goto exit;
+		}
+	}
+
+	/* Try 1G Samsung/Micron.
+	 * If fails, we give up...
+	 */
+	ret = ddr_init(&dram_timing_1gb_samsung_micron);
+	if (ret) {
+		printf("Failed to initialize the DDR with the generic approach, giving up...\n");
+		output = false;
+	} else {
+		printf("DDR 1G Samsung/Micron identified!\n");
+	}
+
+exit:
+	return output;
+}
+
+/* Function used to identify the DDR.
+ * Function returns the timing parameters to use for DDR training, or NULL if failed
+ * to identify the DDR.
+ *
+ * In order to read the DDR values, the function will train the DDR with
+ * default parameters.
+ * Those parameters may be the same parameters needed to train the DDR.
+ * In this case, this function will set @needs_training to false, indicating that
+ * there is no need to train the DDR again.
+ * Caller can ignore this argument without harm (argument can be NULL).
+ */
+static struct dram_timing_info *spl_identify_ddr(bool *needs_training)
+{
+	int ret;
+	unsigned int mr5, mr6, mr7, mr8;
+	bool tmp;
+
+	/*                    Values for 8G Micron training
+	 *
+	 *              MR5     MR6     MR7     MR8
+	 * Micron 8G    255		7		0		24
+	 *
+	 *                    Values for 3G Micron training
+	 *
+	 *		MR5	|	M6	|	MR7	|	MR8
+	 * Samsung 1G   ************** TRAINING FAILURE ********************
+	 * Micron 1G    ************** TRAINING FAILURE ********************
+	 * Samsung 2G   ************** TRAINING FAILURE ********************
+	 * Micron 3G    255		4		1		12
+	 * Samsung 4G   1		6		16		16
+	 * Micron 4G    255		7		0		16
+	 * Micron 8G    255		7		0		24
+	 *
+	 *   		      Values for 1G Samsung/Micron training
+	 *
+	 *		MR5	|	M6	|	MR7	|	MR8
+	 * Samsung 1G   1               6               0               8
+	 * Micron 1G    255		3		0		8
+	 * Samsung 2G   1		6		16		16
+	 * Micron 3G    255		4		1		12
+	 * Samsung 4G   ****************** UNSTABLE ************************
+	 * Micron 4G    ****************** UNSTABLE ************************
+	 * Micron 8G    255		0		0		0
+	 *
+	 * Algorithm:
+	 * DDR training with 3G Micron, if succeeds, check if this is a 3G Micron,
+	 * 4G Samsung/Micron, 8G Micron, or unknown.
+	 * If fails, DDR training with 1G Samsung/Micron, check if this is a 2G Samsung,
+	 * 1G Samsung, 1G Micron or unknown.
+	 */
+
+	/* Init the @needs_training argument */
+	if (!needs_training)
+		needs_training = &tmp;
+	*needs_training = true;
+
+	/* Training with 3G Micron */
+	if (!ddr_init(&dram_timing_3gb_micron)) {
+		/* Training with 3G Micron succedded */
+		mr5 = lpddr4_mr_read(0xF, 0x5);
+		mr6 = lpddr4_mr_read(0xF, 0x6);
+		mr7 = lpddr4_mr_read(0xF, 0x7);
+		mr8 = lpddr4_mr_read(0xF, 0x8);
+
+		debug("MR5=0x%x, MR6=0x%x, MR7=0x%x, MR8=0x%x\n", mr5, mr6, mr7, mr8);
+
+		if (mr5 == 0xFF && mr6 == 0x4 && mr7 == 0x1 && mr8 == 0xC) {
+			printf("DDR 3G Micron identified!\n");
+			*needs_training = false;
+			return &dram_timing_3gb_micron;
+		} else if (mr5 == 0x1 && mr6 == 0x6 && mr7 == 0x10 && mr8 == 0x10) {
+			printf("DDR 4G Samsung identified!\n");
+			return &dram_timing_4gb_samsung_micron;
+		} else if (mr5 == 0xFF && mr6 == 0x7 && mr7 == 0x0 && mr8 == 0x10) {
+			printf("DDR 4G Micron identified!\n");
+			return &dram_timing_4gb_samsung_micron;
+		} else if (mr5 == 0xFF && mr6 == 0x7 && mr7 == 0x0 && mr8 == 0x18) {
+			printf("DDR 8G Micron identified!\n");
+			timing_patch_apply(&dram_timing_4gb_samsung_micron, &dram_timing_patch_8gb_micron);
+			return &dram_timing_4gb_samsung_micron;
+		} else {
+			goto err;
+		}
+	} else {
+		/* Training with 3G Micron failed
+		 * DDR training with 1G Samsung/Micron
+		 */
+		ret = ddr_init(&dram_timing_1gb_samsung_micron);
+		if (ret)
+			goto err;
+
+		mr5 = lpddr4_mr_read(0xF, 0x5);
+		mr6 = lpddr4_mr_read(0xF, 0x6);
+		mr7 = lpddr4_mr_read(0xF, 0x7);
+		mr8 = lpddr4_mr_read(0xF, 0x8);
+
+		debug("MR5=0x%x, MR6=0x%x, MR7=0x%x, MR8=0x%x\n", mr5, mr6, mr7, mr8);
+
+		if (mr5 == 0x1 && mr6 == 0x6 && mr7 == 0x0 && mr8 == 0x8) {
+			printf("DDR 1G Samsung identified!\n");
+			*needs_training = false;
+			return &dram_timing_1gb_samsung_micron;
+		} else if (mr5 == 0xFF && mr6 == 0x3 && mr7 == 0x0 && mr8 == 0x8) {
+			printf("DDR 1G Micron identified!\n");
+			*needs_training = false;
+			return &dram_timing_1gb_samsung_micron;
+		} else if (mr5 == 0x1 && mr6 == 0x6 && mr7 == 0x10 && mr8 == 0x10) {
+			printf("DDR 2G Samsung identified!\n");
+			timing_patch_apply(&dram_timing_1gb_samsung_micron, &dram_timing_patch_2gb_samsung);
+			return &dram_timing_1gb_samsung_micron;
+		} else {
+			goto err;
+		}
+	}
+
+err:
+	printf("Could not identify DDR!\n");
+	return NULL;
+}
+
 void spl_dram_init(void)
 {
-	ddr_init(&dram_timing);
+		struct dram_timing_info *dram_info;
+	int ret = -1;
+	bool need_training;
+
+#ifdef PRINT_DDR_TABLES
+	spl_print_ddr_tables();
+#endif
+	dram_info = spl_identify_ddr(&need_training);
+	if (dram_info) {
+		/* DDR was identified, do we need to train the DDR? */
+		if (need_training)
+			ret = ddr_init(dram_info);
+		else
+			ret = 0;
+	}
+
+	/* If we failed to identify the DDR, or the parameters returned from
+	 * spl_identify_ddr caused in DDR training failure - fall back to a
+	 * generic way to train the DDR.
+	 */
+	if (ret == -1) {
+		if (!spl_generic_ddr_init())
+			hang(); //Could not init the DDR - nothing we can do..
+	}
 }
 
 void spl_board_init(void)
@@ -98,18 +432,13 @@ int power_init_board(void)
 	/* BUCKxOUT_DVS0/1 control BUCK123 output */
 	pmic_reg_write(dev, PCA9450_BUCK123_DVS, 0x29);
 
-#ifdef CONFIG_IMX8M_LPDDR4
 	/*
 	 * Increase VDD_SOC to typical value 0.95V before first
 	 * DRAM access, set DVS1 to 0.85V for suspend.
 	 * Enable DVS control through PMIC_STBY_REQ and
 	 * set B1_ENMODE=1 (ON by PMIC_ON_REQ=H)
 	 */
-	if (CONFIG_IS_ENABLED(IMX8M_VDD_SOC_850MV))
-		pmic_reg_write(dev, PCA9450_BUCK1OUT_DVS0, 0x14);
-	else
-		pmic_reg_write(dev, PCA9450_BUCK1OUT_DVS0, 0x1C);
-
+	pmic_reg_write(dev, PCA9450_BUCK1OUT_DVS0, 0x1C);
 	pmic_reg_write(dev, PCA9450_BUCK1OUT_DVS1, 0x14);
 	pmic_reg_write(dev, PCA9450_BUCK1CTRL, 0x59);
 
@@ -120,13 +449,10 @@ int power_init_board(void)
 	 */
 
 	pmic_reg_write(dev, PCA9450_BUCK2OUT_DVS0, 0x1C);
-#elif defined(CONFIG_IMX8M_DDR4)
-	/* DDR4 runs at 3200MTS, uses default ND 0.85v for VDD_SOC and VDD_ARM */
-	pmic_reg_write(dev, PCA9450_BUCK1CTRL, 0x59);
 
-	/* Set NVCC_DRAM to 1.2v for DDR4 */
-	pmic_reg_write(dev, PCA9450_BUCK6OUT, 0x18);
-#endif
+	/* set WDOG_B_CFG to cold reset */
+	// OMAR: Solidrun does not do this, commenting out
+	// pmic_reg_write(dev, PCA9450_RESET_CTRL, 0xA1);
 
 	return 0;
 }
@@ -156,6 +482,8 @@ void board_init_f(ulong dummy)
 
 	timer_init();
 
+	// OMAR: Conisider moving preloader_console_init() call here as solidrun does
+
 	ret = spl_early_init();
 	if (ret) {
 		debug("spl_early_init() failed: %d\n", ret);
diff --git a/cmd/Kconfig b/cmd/Kconfig
index 413051ac4a1..86bbe39c7a3 100644
--- a/cmd/Kconfig
+++ b/cmd/Kconfig
@@ -212,6 +212,7 @@ config CMD_REGINFO
 
 config CMD_TLV_EEPROM
 	bool "tlv_eeprom"
+	select EEPROM_TLV_LIB
 	depends on I2C_EEPROM
 	select CRC32
 	help
@@ -220,6 +221,7 @@ config CMD_TLV_EEPROM
 
 config SPL_CMD_TLV_EEPROM
 	bool "tlv_eeprom for SPL"
+	select EEPROM_TLV_LIB
 	depends on SPL_I2C_EEPROM
 	select SPL_DRIVERS_MISC
 	select SPL_CRC32
diff --git a/cmd/tlv_eeprom.c b/cmd/tlv_eeprom.c
index 57cfd355df1..289a9b6257b 100644
--- a/cmd/tlv_eeprom.c
+++ b/cmd/tlv_eeprom.c
@@ -7,152 +7,29 @@
  * Copyright (C) 2014 Srideep <srideep_devireddy@dell.com>
  * Copyright (C) 2013 Miles Tseng <miles_tseng@accton.com>
  * Copyright (C) 2014,2016 david_yang <david_yang@accton.com>
+ * Copyright (C) 2022 Josua Mayer <josua@solid-run.com>
  */
 
-#include <common.h>
 #include <command.h>
-#include <dm.h>
-#include <i2c.h>
-#include <i2c_eeprom.h>
-#include <env.h>
-#include <init.h>
-#include <net.h>
-#include <asm/global_data.h>
-#include <linux/ctype.h>
-#include <u-boot/crc.h>
-
-#include "tlv_eeprom.h"
-
-DECLARE_GLOBAL_DATA_PTR;
-
-#define MAX_TLV_DEVICES	2
+#include <linux/kernel.h>
+#include <stdio.h>
+#include <tlv_eeprom.h>
+#include <vsprintf.h>
 
 /* File scope function prototypes */
-static bool is_checksum_valid(u8 *eeprom);
-static int read_eeprom(int devnum, u8 *eeprom);
 static void show_eeprom(int devnum, u8 *eeprom);
-static void decode_tlv(struct tlvinfo_tlv *tlv);
-static void update_crc(u8 *eeprom);
-static int prog_eeprom(int devnum, u8 *eeprom);
-static bool tlvinfo_find_tlv(u8 *eeprom, u8 tcode, int *eeprom_index);
-static bool tlvinfo_delete_tlv(u8 *eeprom, u8 code);
-static bool tlvinfo_add_tlv(u8 *eeprom, int tcode, char *strval);
-static int set_mac(char *buf, const char *string);
-static int set_date(char *buf, const char *string);
-static int set_bytes(char *buf, const char *string, int *converted_accum);
 static void show_tlv_devices(int current_dev);
+static inline const char *tlv_type2name(u8 type);
+static void decode_tlv(struct tlvinfo_tlv *tlv);
+static int do_tlv_eeprom(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[]);
+static void show_tlv_code_list(void);
 
 /* The EERPOM contents after being read into memory */
 static u8 eeprom[TLV_INFO_MAX_LEN];
 
-static struct udevice *tlv_devices[MAX_TLV_DEVICES];
-
 #define to_header(p) ((struct tlvinfo_header *)p)
 #define to_entry(p) ((struct tlvinfo_tlv *)p)
 
-#define HDR_SIZE sizeof(struct tlvinfo_header)
-#define ENT_SIZE sizeof(struct tlvinfo_tlv)
-
-static inline bool is_digit(char c)
-{
-	return (c >= '0' && c <= '9');
-}
-
-/**
- *  is_valid_tlv
- *
- *  Perform basic sanity checks on a TLV field. The TLV is pointed to
- *  by the parameter provided.
- *      1. The type code is not reserved (0x00 or 0xFF)
- */
-static inline bool is_valid_tlv(struct tlvinfo_tlv *tlv)
-{
-	return((tlv->type != 0x00) && (tlv->type != 0xFF));
-}
-
-/**
- *  is_hex
- *
- *  Tests if character is an ASCII hex digit
- */
-static inline u8 is_hex(char p)
-{
-	return (((p >= '0') && (p <= '9')) ||
-		((p >= 'A') && (p <= 'F')) ||
-		((p >= 'a') && (p <= 'f')));
-}
-
-/**
- *  is_checksum_valid
- *
- *  Validate the checksum in the provided TlvInfo EEPROM data. First,
- *  verify that the TlvInfo header is valid, then make sure the last
- *  TLV is a CRC-32 TLV. Then calculate the CRC over the EEPROM data
- *  and compare it to the value stored in the EEPROM CRC-32 TLV.
- */
-static bool is_checksum_valid(u8 *eeprom)
-{
-	struct tlvinfo_header *eeprom_hdr = to_header(eeprom);
-	struct tlvinfo_tlv    *eeprom_crc;
-	unsigned int       calc_crc;
-	unsigned int       stored_crc;
-
-	// Is the eeprom header valid?
-	if (!is_valid_tlvinfo_header(eeprom_hdr))
-		return false;
-
-	// Is the last TLV a CRC?
-	eeprom_crc = to_entry(&eeprom[HDR_SIZE +
-		be16_to_cpu(eeprom_hdr->totallen) - (ENT_SIZE + 4)]);
-	if (eeprom_crc->type != TLV_CODE_CRC_32 || eeprom_crc->length != 4)
-		return false;
-
-	// Calculate the checksum
-	calc_crc = crc32(0, (void *)eeprom,
-			 HDR_SIZE + be16_to_cpu(eeprom_hdr->totallen) - 4);
-	stored_crc = (eeprom_crc->value[0] << 24) |
-		(eeprom_crc->value[1] << 16) |
-		(eeprom_crc->value[2] <<  8) |
-		eeprom_crc->value[3];
-	return calc_crc == stored_crc;
-}
-
-/**
- *  read_eeprom
- *
- *  Read the EEPROM into memory, if it hasn't already been read.
- */
-static int read_eeprom(int devnum, u8 *eeprom)
-{
-	int ret;
-	struct tlvinfo_header *eeprom_hdr = to_header(eeprom);
-	struct tlvinfo_tlv *eeprom_tlv = to_entry(&eeprom[HDR_SIZE]);
-
-	/* Read the header */
-	ret = read_tlv_eeprom((void *)eeprom_hdr, 0, HDR_SIZE, devnum);
-	/* If the header was successfully read, read the TLVs */
-	if (ret == 0 && is_valid_tlvinfo_header(eeprom_hdr))
-		ret = read_tlv_eeprom((void *)eeprom_tlv, HDR_SIZE,
-				      be16_to_cpu(eeprom_hdr->totallen), devnum);
-	else if (ret == -ENODEV)
-		return ret;
-
-	// If the contents are invalid, start over with default contents
-	if (!is_valid_tlvinfo_header(eeprom_hdr) ||
-	    !is_checksum_valid(eeprom)) {
-		strcpy(eeprom_hdr->signature, TLV_INFO_ID_STRING);
-		eeprom_hdr->version = TLV_INFO_VERSION;
-		eeprom_hdr->totallen = cpu_to_be16(0);
-		update_crc(eeprom);
-	}
-
-#ifdef DEBUG
-	show_eeprom(devnum, eeprom);
-#endif
-
-	return ret;
-}
-
 /**
  *  show_eeprom
  *
@@ -181,21 +58,21 @@ static void show_eeprom(int devnum, u8 *eeprom)
 
 	printf("TLV Name             Code Len Value\n");
 	printf("-------------------- ---- --- -----\n");
-	curr_tlv = HDR_SIZE;
-	tlv_end  = HDR_SIZE + be16_to_cpu(eeprom_hdr->totallen);
+	curr_tlv = TLV_INFO_HEADER_SIZE;
+	tlv_end  = TLV_INFO_HEADER_SIZE + be16_to_cpu(eeprom_hdr->totallen);
 	while (curr_tlv < tlv_end) {
 		eeprom_tlv = to_entry(&eeprom[curr_tlv]);
-		if (!is_valid_tlv(eeprom_tlv)) {
+		if (!is_valid_tlvinfo_entry(eeprom_tlv)) {
 			printf("Invalid TLV field starting at EEPROM offset %d\n",
 			       curr_tlv);
 			return;
 		}
 		decode_tlv(eeprom_tlv);
-		curr_tlv += ENT_SIZE + eeprom_tlv->length;
+		curr_tlv += TLV_INFO_ENTRY_SIZE + eeprom_tlv->length;
 	}
 
 	printf("Checksum is %s.\n",
-	       is_checksum_valid(eeprom) ? "valid" : "invalid");
+		   tlvinfo_check_crc(eeprom) ? "valid" : "invalid");
 
 #ifdef DEBUG
 	printf("EEPROM dump: (0x%x bytes)", TLV_INFO_MAX_LEN);
@@ -342,87 +219,27 @@ static void decode_tlv(struct tlvinfo_tlv *tlv)
 }
 
 /**
- *  update_crc
- *
- *  This function updates the CRC-32 TLV. If there is no CRC-32 TLV, then
- *  one is added. This function should be called after each update to the
- *  EEPROM structure, to make sure the CRC is always correct.
- */
-static void update_crc(u8 *eeprom)
-{
-	struct tlvinfo_header *eeprom_hdr = to_header(eeprom);
-	struct tlvinfo_tlv    *eeprom_crc;
-	unsigned int      calc_crc;
-	int               eeprom_index;
-
-	// Discover the CRC TLV
-	if (!tlvinfo_find_tlv(eeprom, TLV_CODE_CRC_32, &eeprom_index)) {
-		unsigned int totallen = be16_to_cpu(eeprom_hdr->totallen);
-
-		if ((totallen + ENT_SIZE + 4) > TLV_TOTAL_LEN_MAX)
-			return;
-		eeprom_index = HDR_SIZE + totallen;
-		eeprom_hdr->totallen = cpu_to_be16(totallen + ENT_SIZE + 4);
-	}
-	eeprom_crc = to_entry(&eeprom[eeprom_index]);
-	eeprom_crc->type = TLV_CODE_CRC_32;
-	eeprom_crc->length = 4;
-
-	// Calculate the checksum
-	calc_crc = crc32(0, (void *)eeprom,
-			 HDR_SIZE + be16_to_cpu(eeprom_hdr->totallen) - 4);
-	eeprom_crc->value[0] = (calc_crc >> 24) & 0xFF;
-	eeprom_crc->value[1] = (calc_crc >> 16) & 0xFF;
-	eeprom_crc->value[2] = (calc_crc >>  8) & 0xFF;
-	eeprom_crc->value[3] = (calc_crc >>  0) & 0xFF;
-}
-
-/**
- *  prog_eeprom
- *
- *  Write the EEPROM data from CPU memory to the hardware.
- */
-static int prog_eeprom(int devnum, u8 *eeprom)
-{
-	int ret = 0;
-	struct tlvinfo_header *eeprom_hdr = to_header(eeprom);
-	int eeprom_len;
-
-	update_crc(eeprom);
-
-	eeprom_len = HDR_SIZE + be16_to_cpu(eeprom_hdr->totallen);
-	ret = write_tlv_eeprom(eeprom, eeprom_len, devnum);
-	if (ret) {
-		printf("Programming failed.\n");
-		return -1;
-	}
-
-	printf("Programming passed.\n");
-	return 0;
-}
-
-/**
- *  show_tlv_code_list - Display the list of TLV codes and names
- */
-void show_tlv_code_list(void)
+  *  show_tlv_code_list - Display the list of TLV codes and names
+  */
+static void show_tlv_code_list(void)
 {
 	int i;
 
-	printf("TLV Code    TLV Name\n");
-	printf("========    =================\n");
-	for (i = 0; i < ARRAY_SIZE(tlv_code_list); i++) {
-		printf("0x%02X        %s\n",
-		       tlv_code_list[i].m_code,
-		       tlv_code_list[i].m_name);
-	}
+    printf("TLV Code    TLV Name\n");
+    printf("========    =================\n");
+    for (i = 0; i < ARRAY_SIZE(tlv_code_list); i++) {
+	    printf("0x%02X        %s\n",
+                tlv_code_list[i].m_code,
+                tlv_code_list[i].m_name);
+    }
 }
 
-/**
+/** 
  *  do_tlv_eeprom
  *
  *  This function implements the tlv_eeprom command.
  */
-int do_tlv_eeprom(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
+static int do_tlv_eeprom(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
 {
 	char cmd;
 	struct tlvinfo_header *eeprom_hdr = to_header(eeprom);
@@ -434,7 +251,8 @@ int do_tlv_eeprom(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
 	// If no arguments, read the EERPOM and display its contents
 	if (argc == 1) {
 		if (!has_been_read) {
-			ret = read_eeprom(current_dev, eeprom);
+			// ret = read_eeprom(current_dev, eeprom);
+			ret = read_tlv_eeprom(eeprom, 0, TLV_INFO_MAX_LEN, current_dev);
 			if (ret) {
 				printf("Failed to read EEPROM data from device.\n");
 				return 0;
@@ -456,7 +274,7 @@ int do_tlv_eeprom(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
 		unsigned int devnum;
 
 		devnum = simple_strtoul(argv[2], NULL, 0);
-		if (devnum >= MAX_TLV_DEVICES) {
+		if (!exists_tlv_eeprom(devnum)) {
 			printf("Invalid device number\n");
 			return 0;
 		}
@@ -469,7 +287,8 @@ int do_tlv_eeprom(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
 	// Read the EEPROM contents
 	if (cmd == 'r') {
 		has_been_read = 0;
-		ret = read_eeprom(current_dev, eeprom);
+		// ret = read_eeprom(current_dev, eeprom);
+		ret = read_tlv_eeprom(eeprom, 0, TLV_INFO_MAX_LEN, current_dev);
 		if (ret) {
 			printf("Failed to read EEPROM data from device.\n");
 			return 0;
@@ -489,13 +308,13 @@ int do_tlv_eeprom(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
 	if (argc == 2) {
 		switch (cmd) {
 		case 'w':   /* write */
-			prog_eeprom(current_dev, eeprom);
+			write_tlvinfo_tlv_eeprom(eeprom, current_dev);
 			break;
 		case 'e':   /* erase */
 			strcpy(eeprom_hdr->signature, TLV_INFO_ID_STRING);
 			eeprom_hdr->version = TLV_INFO_VERSION;
 			eeprom_hdr->totallen = cpu_to_be16(0);
-			update_crc(eeprom);
+			tlvinfo_update_crc(eeprom);
 			printf("EEPROM data in memory reset.\n");
 			break;
 		case 'l':   /* list */
@@ -557,557 +376,12 @@ U_BOOT_CMD(tlv_eeprom, 4, 1,  do_tlv_eeprom,
 	   "    - List the understood TLV codes and names.\n"
 	);
 
-/**
- *  tlvinfo_find_tlv
- *
- *  This function finds the TLV with the supplied code in the EERPOM.
- *  An offset from the beginning of the EEPROM is returned in the
- *  eeprom_index parameter if the TLV is found.
- */
-static bool tlvinfo_find_tlv(u8 *eeprom, u8 tcode, int *eeprom_index)
-{
-	struct tlvinfo_header *eeprom_hdr = to_header(eeprom);
-	struct tlvinfo_tlv    *eeprom_tlv;
-	int eeprom_end;
-
-	// Search through the TLVs, looking for the first one which matches the
-	// supplied type code.
-	*eeprom_index = HDR_SIZE;
-	eeprom_end = HDR_SIZE + be16_to_cpu(eeprom_hdr->totallen);
-	while (*eeprom_index < eeprom_end) {
-		eeprom_tlv = to_entry(&eeprom[*eeprom_index]);
-		if (!is_valid_tlv(eeprom_tlv))
-			return false;
-		if (eeprom_tlv->type == tcode)
-			return true;
-		*eeprom_index += ENT_SIZE + eeprom_tlv->length;
-	}
-	return(false);
-}
-
-/**
- *  tlvinfo_delete_tlv
- *
- *  This function deletes the TLV with the specified type code from the
- *  EEPROM.
- */
-static bool tlvinfo_delete_tlv(u8 *eeprom, u8 code)
-{
-	int eeprom_index;
-	int tlength;
-	struct tlvinfo_header *eeprom_hdr = to_header(eeprom);
-	struct tlvinfo_tlv *eeprom_tlv;
-
-	// Find the TLV and then move all following TLVs "forward"
-	if (tlvinfo_find_tlv(eeprom, code, &eeprom_index)) {
-		eeprom_tlv = to_entry(&eeprom[eeprom_index]);
-		tlength = ENT_SIZE + eeprom_tlv->length;
-		memcpy(&eeprom[eeprom_index], &eeprom[eeprom_index + tlength],
-		       HDR_SIZE +
-		       be16_to_cpu(eeprom_hdr->totallen) - eeprom_index -
-		       tlength);
-		eeprom_hdr->totallen =
-			cpu_to_be16(be16_to_cpu(eeprom_hdr->totallen) -
-				    tlength);
-		update_crc(eeprom);
-		return true;
-	}
-	return false;
-}
-
-/**
- *  tlvinfo_add_tlv
- *
- *  This function adds a TLV to the EEPROM, converting the value (a string) to
- *  the format in which it will be stored in the EEPROM.
- */
-#define MAX_TLV_VALUE_LEN   256
-static bool tlvinfo_add_tlv(u8 *eeprom, int tcode, char *strval)
-{
-	struct tlvinfo_header *eeprom_hdr = to_header(eeprom);
-	struct tlvinfo_tlv *eeprom_tlv;
-	int new_tlv_len = 0;
-	u32 value;
-	char data[MAX_TLV_VALUE_LEN];
-	int eeprom_index;
-
-	// Encode each TLV type into the format to be stored in the EERPOM
-	switch (tcode) {
-	case TLV_CODE_PRODUCT_NAME:
-	case TLV_CODE_PART_NUMBER:
-	case TLV_CODE_SERIAL_NUMBER:
-	case TLV_CODE_LABEL_REVISION:
-	case TLV_CODE_PLATFORM_NAME:
-	case TLV_CODE_ONIE_VERSION:
-	case TLV_CODE_MANUF_NAME:
-	case TLV_CODE_MANUF_COUNTRY:
-	case TLV_CODE_VENDOR_NAME:
-	case TLV_CODE_DIAG_VERSION:
-	case TLV_CODE_SERVICE_TAG:
-		strncpy(data, strval, MAX_TLV_VALUE_LEN);
-		new_tlv_len = min_t(size_t, MAX_TLV_VALUE_LEN, strlen(strval));
-		break;
-	case TLV_CODE_DEVICE_VERSION:
-		value = simple_strtoul(strval, NULL, 0);
-		if (value >= 256) {
-			printf("ERROR: Device version must be 255 or less. Value supplied: %u",
-			       value);
-			return false;
-		}
-		data[0] = value & 0xFF;
-		new_tlv_len = 1;
-		break;
-	case TLV_CODE_MAC_SIZE:
-		value = simple_strtoul(strval, NULL, 0);
-		if (value >= 65536) {
-			printf("ERROR: MAC Size must be 65535 or less. Value supplied: %u",
-			       value);
-			return false;
-		}
-		data[0] = (value >> 8) & 0xFF;
-		data[1] = value & 0xFF;
-		new_tlv_len = 2;
-		break;
-	case TLV_CODE_MANUF_DATE:
-		if (set_date(data, strval) != 0)
-			return false;
-		new_tlv_len = 19;
-		break;
-	case TLV_CODE_MAC_BASE:
-		if (set_mac(data, strval) != 0)
-			return false;
-		new_tlv_len = 6;
-		break;
-	case TLV_CODE_CRC_32:
-		printf("WARNING: The CRC TLV is set automatically and cannot be set manually.\n");
-		return false;
-	case TLV_CODE_VENDOR_EXT:
-	default:
-		if (set_bytes(data, strval, &new_tlv_len) != 0)
-			return false;
-		break;
-	}
-
-	// Is there room for this TLV?
-	if ((be16_to_cpu(eeprom_hdr->totallen) + ENT_SIZE + new_tlv_len) >
-			TLV_TOTAL_LEN_MAX) {
-		printf("ERROR: There is not enough room in the EERPOM to save data.\n");
-		return false;
-	}
-
-	// Add TLV at the end, overwriting CRC TLV if it exists
-	if (tlvinfo_find_tlv(eeprom, TLV_CODE_CRC_32, &eeprom_index))
-		eeprom_hdr->totallen =
-			cpu_to_be16(be16_to_cpu(eeprom_hdr->totallen) -
-					ENT_SIZE - 4);
-	else
-		eeprom_index = HDR_SIZE + be16_to_cpu(eeprom_hdr->totallen);
-	eeprom_tlv = to_entry(&eeprom[eeprom_index]);
-	eeprom_tlv->type = tcode;
-	eeprom_tlv->length = new_tlv_len;
-	memcpy(eeprom_tlv->value, data, new_tlv_len);
-
-	// Update the total length and calculate (add) a new CRC-32 TLV
-	eeprom_hdr->totallen = cpu_to_be16(be16_to_cpu(eeprom_hdr->totallen) +
-			ENT_SIZE + new_tlv_len);
-	update_crc(eeprom);
-
-	return true;
-}
-
-/**
- *  set_mac
- *
- *  Converts a string MAC address into a binary buffer.
- *
- *  This function takes a pointer to a MAC address string
- *  (i.e."XX:XX:XX:XX:XX:XX", where "XX" is a two-digit hex number).
- *  The string format is verified and then converted to binary and
- *  stored in a buffer.
- */
-static int set_mac(char *buf, const char *string)
-{
-	char *p = (char *)string;
-	int   i;
-	int   err = 0;
-	char *end;
-
-	if (!p) {
-		printf("ERROR: NULL mac addr string passed in.\n");
-		return -1;
-	}
-
-	if (strlen(p) != 17) {
-		printf("ERROR: MAC address strlen() != 17 -- %zu\n", strlen(p));
-		printf("ERROR: Bad MAC address format: %s\n", string);
-		return -1;
-	}
-
-	for (i = 0; i < 17; i++) {
-		if ((i % 3) == 2) {
-			if (p[i] != ':') {
-				err++;
-				printf("ERROR: mac: p[%i] != :, found: `%c'\n",
-				       i, p[i]);
-				break;
-			}
-			continue;
-		} else if (!is_hex(p[i])) {
-			err++;
-			printf("ERROR: mac: p[%i] != hex digit, found: `%c'\n",
-			       i, p[i]);
-			break;
-		}
-	}
-
-	if (err != 0) {
-		printf("ERROR: Bad MAC address format: %s\n", string);
-		return -1;
-	}
-
-	/* Convert string to binary */
-	for (i = 0, p = (char *)string; i < 6; i++) {
-		buf[i] = p ? hextoul(p, &end) : 0;
-		if (p)
-			p = (*end) ? end + 1 : end;
-	}
-
-	if (!is_valid_ethaddr((u8 *)buf)) {
-		printf("ERROR: MAC address must not be 00:00:00:00:00:00, a multicast address or FF:FF:FF:FF:FF:FF.\n");
-		printf("ERROR: Bad MAC address format: %s\n", string);
-		return -1;
-	}
-
-	return 0;
-}
-
-/**
- *  set_date
- *
- *  Validates the format of the data string
- *
- *  This function takes a pointer to a date string (i.e. MM/DD/YYYY hh:mm:ss)
- *  and validates that the format is correct. If so the string is copied
- *  to the supplied buffer.
- */
-static int set_date(char *buf, const char *string)
-{
-	int i;
-
-	if (!string) {
-		printf("ERROR: NULL date string passed in.\n");
-		return -1;
-	}
-
-	if (strlen(string) != 19) {
-		printf("ERROR: Date strlen() != 19 -- %zu\n", strlen(string));
-		printf("ERROR: Bad date format (MM/DD/YYYY hh:mm:ss): %s\n",
-		       string);
-		return -1;
-	}
-
-	for (i = 0; string[i] != 0; i++) {
-		switch (i) {
-		case 2:
-		case 5:
-			if (string[i] != '/') {
-				printf("ERROR: Bad date format (MM/DD/YYYY hh:mm:ss): %s\n",
-				       string);
-				return -1;
-			}
-			break;
-		case 10:
-			if (string[i] != ' ') {
-				printf("ERROR: Bad date format (MM/DD/YYYY hh:mm:ss): %s\n",
-				       string);
-				return -1;
-			}
-			break;
-		case 13:
-		case 16:
-			if (string[i] != ':') {
-				printf("ERROR: Bad date format (MM/DD/YYYY hh:mm:ss): %s\n",
-				       string);
-				return -1;
-			}
-			break;
-		default:
-			if (!is_digit(string[i])) {
-				printf("ERROR: Bad date format (MM/DD/YYYY hh:mm:ss): %s\n",
-				       string);
-				return -1;
-			}
-			break;
-		}
-	}
-
-	strcpy(buf, string);
-	return 0;
-}
-
-/**
- *  set_bytes
- *
- *  Converts a space-separated string of decimal numbers into a
- *  buffer of bytes.
- *
- *  This function takes a pointer to a space-separated string of decimal
- *  numbers (i.e. "128 0x55 0321") with "C" standard radix specifiers
- *  and converts them to an array of bytes.
- */
-static int set_bytes(char *buf, const char *string, int *converted_accum)
-{
-	char *p = (char *)string;
-	int   i;
-	uint  byte;
-
-	if (!p) {
-		printf("ERROR: NULL string passed in.\n");
-		return -1;
-	}
-
-	/* Convert string to bytes */
-	for (i = 0, p = (char *)string; (i < TLV_VALUE_MAX_LEN) && (*p != 0);
-			i++) {
-		while ((*p == ' ') || (*p == '\t') || (*p == ',') ||
-		       (*p == ';')) {
-			p++;
-		}
-		if (*p != 0) {
-			if (!is_digit(*p)) {
-				printf("ERROR: Non-digit found in byte string: (%s)\n",
-				       string);
-				return -1;
-			}
-			byte = simple_strtoul(p, &p, 0);
-			if (byte >= 256) {
-				printf("ERROR: The value specified is greater than 255: (%u) in string: %s\n",
-				       byte, string);
-				return -1;
-			}
-			buf[i] = byte & 0xFF;
-		}
-	}
-
-	if (i == TLV_VALUE_MAX_LEN && (*p != 0)) {
-		printf("ERROR: Trying to assign too many bytes (max: %d) in string: %s\n",
-		       TLV_VALUE_MAX_LEN, string);
-		return -1;
-	}
-
-	*converted_accum = i;
-	return 0;
-}
-
 static void show_tlv_devices(int current_dev)
 {
 	unsigned int dev;
 
-	for (dev = 0; dev < MAX_TLV_DEVICES; dev++)
-		if (tlv_devices[dev])
+	for (dev = 0; dev < TLV_MAX_DEVICES; dev++)
+		if (exists_tlv_eeprom(dev))
 			printf("TLV: %u%s\n", dev,
 			       (dev == current_dev) ? " (*)" : "");
 }
-
-static int find_tlv_devices(struct udevice **tlv_devices_p)
-{
-	int ret;
-	int count_dev = 0;
-	struct udevice *dev;
-
-	for (ret = uclass_first_device_check(UCLASS_I2C_EEPROM, &dev);
-			dev;
-			ret = uclass_next_device_check(&dev)) {
-		if (ret == 0)
-			tlv_devices_p[count_dev++] = dev;
-		if (count_dev >= MAX_TLV_DEVICES)
-			break;
-	}
-
-	return (count_dev == 0) ? -ENODEV : 0;
-}
-
-static struct udevice *find_tlv_device_by_index(int dev_num)
-{
-	struct udevice *local_tlv_devices[MAX_TLV_DEVICES] = {};
-	struct udevice **tlv_devices_p;
-	int ret;
-
-	if (gd->flags & (GD_FLG_RELOC | GD_FLG_SPL_INIT)) {
-		/* Assume BSS is initialized; use static data */
-		if (tlv_devices[dev_num])
-			return tlv_devices[dev_num];
-		tlv_devices_p = tlv_devices;
-	} else {
-		tlv_devices_p = local_tlv_devices;
-	}
-
-	ret = find_tlv_devices(tlv_devices_p);
-	if (ret == 0 && tlv_devices_p[dev_num])
-		return tlv_devices_p[dev_num];
-
-	return NULL;
-}
-
-/**
- * read_tlv_eeprom - read the hwinfo from i2c EEPROM
- */
-int read_tlv_eeprom(void *eeprom, int offset, int len, int dev_num)
-{
-	struct udevice *dev;
-
-	if (dev_num >= MAX_TLV_DEVICES)
-		return -EINVAL;
-
-	dev = find_tlv_device_by_index(dev_num);
-	if (!dev)
-		return -ENODEV;
-
-	return i2c_eeprom_read(dev, offset, eeprom, len);
-}
-
-/**
- * write_tlv_eeprom - write the hwinfo to i2c EEPROM
- */
-int write_tlv_eeprom(void *eeprom, int len, int dev)
-{
-	if (!(gd->flags & GD_FLG_RELOC))
-		return -ENODEV;
-	if (!tlv_devices[dev])
-		return -ENODEV;
-
-	return i2c_eeprom_write(tlv_devices[dev], 0, eeprom, len);
-}
-
-int read_tlvinfo_tlv_eeprom(void *eeprom, struct tlvinfo_header **hdr,
-			    struct tlvinfo_tlv **first_entry, int dev_num)
-{
-	int ret;
-	struct tlvinfo_header *tlv_hdr;
-	struct tlvinfo_tlv *tlv_ent;
-
-	/* Read TLV header */
-	ret = read_tlv_eeprom(eeprom, 0, HDR_SIZE, dev_num);
-	if (ret < 0)
-		return ret;
-
-	tlv_hdr = eeprom;
-	if (!is_valid_tlvinfo_header(tlv_hdr))
-		return -EINVAL;
-
-	/* Read TLV entries */
-	tlv_ent = to_entry(&tlv_hdr[1]);
-	ret = read_tlv_eeprom(tlv_ent, HDR_SIZE,
-			      be16_to_cpu(tlv_hdr->totallen), dev_num);
-	if (ret < 0)
-		return ret;
-	if (!is_checksum_valid(eeprom))
-		return -EINVAL;
-
-	*hdr = tlv_hdr;
-	*first_entry = tlv_ent;
-
-	return 0;
-}
-
-/**
- *  mac_read_from_eeprom
- *
- *  Read the MAC addresses from EEPROM
- *
- *  This function reads the MAC addresses from EEPROM and sets the
- *  appropriate environment variables for each one read.
- *
- *  The environment variables are only set if they haven't been set already.
- *  This ensures that any user-saved variables are never overwritten.
- *
- *  This function must be called after relocation.
- */
-int mac_read_from_eeprom(void)
-{
-	unsigned int i;
-	int eeprom_index;
-	struct tlvinfo_tlv *eeprom_tlv;
-	int maccount;
-	u8 macbase[6];
-	struct tlvinfo_header *eeprom_hdr = to_header(eeprom);
-	int devnum = 0; // TODO: support multiple EEPROMs
-
-	puts("EEPROM: ");
-
-	if (read_eeprom(devnum, eeprom)) {
-		printf("Read failed.\n");
-		return -1;
-	}
-
-	maccount = 1;
-	if (tlvinfo_find_tlv(eeprom, TLV_CODE_MAC_SIZE, &eeprom_index)) {
-		eeprom_tlv = to_entry(&eeprom[eeprom_index]);
-		maccount = (eeprom_tlv->value[0] << 8) | eeprom_tlv->value[1];
-	}
-
-	memcpy(macbase, "\0\0\0\0\0\0", 6);
-	if (tlvinfo_find_tlv(eeprom, TLV_CODE_MAC_BASE, &eeprom_index)) {
-		eeprom_tlv = to_entry(&eeprom[eeprom_index]);
-		memcpy(macbase, eeprom_tlv->value, 6);
-	}
-
-	for (i = 0; i < maccount; i++) {
-		if (is_valid_ethaddr(macbase)) {
-			char ethaddr[18];
-			char enetvar[11];
-
-			sprintf(ethaddr, "%02X:%02X:%02X:%02X:%02X:%02X",
-				macbase[0], macbase[1], macbase[2],
-				macbase[3], macbase[4], macbase[5]);
-			sprintf(enetvar, i ? "eth%daddr" : "ethaddr", i);
-			/* Only initialize environment variables that are blank
-			 * (i.e. have not yet been set)
-			 */
-			if (!env_get(enetvar))
-				env_set(enetvar, ethaddr);
-
-			macbase[5]++;
-			if (macbase[5] == 0) {
-				macbase[4]++;
-				if (macbase[4] == 0) {
-					macbase[3]++;
-					if (macbase[3] == 0) {
-						macbase[0] = 0;
-						macbase[1] = 0;
-						macbase[2] = 0;
-					}
-				}
-			}
-		}
-	}
-
-	printf("%s v%u len=%u\n", eeprom_hdr->signature, eeprom_hdr->version,
-	       be16_to_cpu(eeprom_hdr->totallen));
-
-	return 0;
-}
-
-int serial_read_from_eeprom(int devnum)
-{
-	char serialstr[257];
-	int eeprom_index;
-	struct tlvinfo_tlv *eeprom_tlv;
-
-	if (env_get("serial#"))
-		return 0;
-
-	if (read_eeprom(devnum, eeprom)) {
-		printf("Read failed.\n");
-		return -1;
-	}
-
-	if (tlvinfo_find_tlv(eeprom, TLV_CODE_SERIAL_NUMBER, &eeprom_index)) {
-		eeprom_tlv = to_entry(&eeprom[eeprom_index]);
-		memcpy(serialstr, eeprom_tlv->value, eeprom_tlv->length);
-		serialstr[eeprom_tlv->length] = 0;
-		env_set("serial#", serialstr);
-	}
-
-	return 0;
-}
diff --git a/configs/imx8mp_solidrun_defconfig b/configs/imx8mp_solidrun_defconfig
index 7112fdf5859..49bf8395bb3 100644
--- a/configs/imx8mp_solidrun_defconfig
+++ b/configs/imx8mp_solidrun_defconfig
@@ -2,6 +2,7 @@ CONFIG_ARM=y
 CONFIG_ARCH_IMX8M=y
 CONFIG_TEXT_BASE=0x40200000
 CONFIG_SYS_MALLOC_LEN=0x2000000
+# CONFIG_SYS_MALLOC_F_LEN=0x10000
 CONFIG_SPL_GPIO=y
 CONFIG_SPL_LIBCOMMON_SUPPORT=y
 CONFIG_SPL_LIBGENERIC_SUPPORT=y
@@ -12,10 +13,15 @@ CONFIG_SYS_MEMTEST_END=0xC0000000
 CONFIG_ENV_SIZE=0x4000
 CONFIG_ENV_OFFSET=0x700000
 CONFIG_ENV_SECT_SIZE=0x10000
+# CONFIG_ENV_SIZE=0x80000
+# CONFIG_ENV_OFFSET=0x380000
+CONFIG_SYS_I2C_MXC_I2C1=y
+CONFIG_SYS_I2C_MXC_I2C2=y
+CONFIG_SYS_I2C_MXC_I2C3=y
 CONFIG_DM_GPIO=y
 CONFIG_SPL_TEXT_BASE=0x920000
 CONFIG_USB_TCPC=y
-CONFIG_TARGET_IMX8MP_EVK=y
+CONFIG_TARGET_IMX8MP_SOLIDRUN=y
 CONFIG_SPL_SERIAL=y
 CONFIG_SPL_DRIVERS_MISC=y
 CONFIG_SPL_STACK=0x96dff0
@@ -24,8 +30,9 @@ CONFIG_SPL_IMX_ROMAPI_LOADADDR=0x48000000
 CONFIG_SYS_LOAD_ADDR=0x40400000
 CONFIG_DISTRO_DEFAULTS=y
 CONFIG_SYS_MONITOR_LEN=524288
-CONFIG_DEFAULT_DEVICE_TREE="imx8mp-evk"
+CONFIG_DEFAULT_DEVICE_TREE="imx8mp-solidrun"
 CONFIG_BOOTCOMMAND="run sr_ir_v2_cmd;run distro_bootcmd;run bsp_bootcmd"
+# CONFIG_BOOTCOMMAND="run distro_bootcmd;run bsp_bootcmd"
 CONFIG_FIT=y
 CONFIG_FIT_EXTERNAL_OFFSET=0x3000
 CONFIG_SPL_LOAD_FIT=y
@@ -33,7 +40,7 @@ CONFIG_REMAKE_ELF=y
 CONFIG_OF_BOARD_FIXUP=y
 CONFIG_OF_BOARD_SETUP=y
 CONFIG_OF_SYSTEM_SETUP=y
-CONFIG_DEFAULT_FDT_FILE="imx8mp-evk.dtb"
+CONFIG_DEFAULT_FDT_FILE="imx8mp-hummingboard-pulse.dtb"
 CONFIG_ARCH_MISC_INIT=y
 CONFIG_BOARD_EARLY_INIT_F=y
 CONFIG_BOARD_LATE_INIT=y
@@ -48,12 +55,14 @@ CONFIG_SPL_SYS_MALLOC=y
 CONFIG_SPL_HAS_CUSTOM_MALLOC_START=y
 CONFIG_SPL_CUSTOM_SYS_MALLOC_ADDR=0x42200000
 CONFIG_SPL_SYS_MALLOC_SIZE=0x80000
+# CONFIG_SPL_SEPARATE_BSS=y
 CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_USE_SECTOR=y
 CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_SECTOR=0x300
 CONFIG_SPL_I2C=y
 CONFIG_SPL_POWER=y
 CONFIG_SPL_WATCHDOG=y
 CONFIG_SYS_PROMPT="u-boot=> "
+CONFIG_SYS_MAXARGS=64
 CONFIG_SYS_CBSIZE=2048
 CONFIG_SYS_PBSIZE=2074
 CONFIG_SYS_BOOTM_LEN=0x2000000
@@ -62,8 +71,8 @@ CONFIG_SYS_BOOTM_LEN=0x2000000
 # CONFIG_CMD_IMPORTENV is not set
 CONFIG_CMD_ERASEENV=y
 CONFIG_CMD_NVEDIT_EFI=y
-CONFIG_CMD_CRC32=y
-CONFIG_CRC32_VERIFY=y
+# https://github.com/nxp-imx/uboot-imx/commit/c8b1d07ff451c334ab95d74c0302278fa11f44e3
+# CONFIG_CMD_CRC32 is not set
 CONFIG_CMD_MEMTEST=y
 CONFIG_CMD_CLK=y
 CONFIG_CMD_DFU=y
@@ -73,7 +82,7 @@ CONFIG_CMD_I2C=y
 CONFIG_CMD_MMC=y
 CONFIG_CMD_POWEROFF=y
 CONFIG_CMD_USB=y
-CONFIG_CMD_USB_SDP=y
+# CONFIG_CMD_USB_SDP=y
 CONFIG_CMD_USB_MASS_STORAGE=y
 CONFIG_CMD_SNTP=y
 CONFIG_CMD_BMP=y
@@ -91,12 +100,12 @@ CONFIG_SPL_OF_CONTROL=y
 CONFIG_ENV_OVERWRITE=y
 CONFIG_ENV_IS_NOWHERE=y
 CONFIG_ENV_IS_IN_MMC=y
-CONFIG_ENV_IS_IN_SPI_FLASH=y
+# CONFIG_ENV_IS_IN_SPI_FLASH is not set
 CONFIG_SYS_RELOC_GD_ENV_ADDR=y
 CONFIG_SYS_MMC_ENV_DEV=1
 CONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG=y
 CONFIG_USE_ETHPRIME=y
-CONFIG_ETHPRIME="eth1"
+CONFIG_ETHPRIME="eth0"
 CONFIG_NET_RANDOM_ETHADDR=y
 CONFIG_SPL_DM=y
 CONFIG_REGMAP=y
@@ -108,6 +117,7 @@ CONFIG_CLK_IMX8MP=y
 CONFIG_DFU_TFTP=y
 CONFIG_DFU_MMC=y
 CONFIG_DFU_RAM=y
+CONFIG_SYS_I2C_MXC=y
 CONFIG_USB_FUNCTION_FASTBOOT=y
 CONFIG_UDP_FUNCTION_FASTBOOT=y
 CONFIG_FASTBOOT_BUF_ADDR=0x42800000
@@ -133,6 +143,7 @@ CONFIG_SF_DEFAULT_SPEED=40000000
 CONFIG_SPI_FLASH_BAR=y
 CONFIG_SPI_FLASH_STMICRO=y
 CONFIG_PHY_REALTEK=y
+CONFIG_DM_ETH=y
 CONFIG_DM_ETH_PHY=y
 CONFIG_PHY_GIGE=y
 CONFIG_PHY=y
@@ -200,6 +211,9 @@ CONFIG_SPL_RSA=y
 CONFIG_SHA384=y
 CONFIG_EFI_VAR_BUF_SIZE=139264
 CONFIG_EFI_IGNORE_OSINDICATIONS=y
+# CONFIG_MISC=y
+CONFIG_I2C_EEPROM=y
+CONFIG_CMD_TLV_EEPROM=y
 CONFIG_EFI_CAPSULE_AUTHENTICATE=y
 CONFIG_EFI_CAPSULE_ESL_FILE="CRT.esl"
 CONFIG_OPTEE=y
diff --git a/drivers/net/dwc_eth_qos.c b/drivers/net/dwc_eth_qos.c
index 8a65017f668..fed3cda0ad4 100644
--- a/drivers/net/dwc_eth_qos.c
+++ b/drivers/net/dwc_eth_qos.c
@@ -669,7 +669,17 @@ static int eqos_write_hwaddr(struct udevice *dev)
 	struct eth_pdata *plat = dev_get_plat(dev);
 	struct eqos_priv *eqos = dev_get_priv(dev);
 	uint32_t val;
+	int ret, stop_clocks = 0;
 
+	if (!eqos->config->reg_access_always_ok && !eqos->reg_access_ok) {
+		ret = eqos->config->ops->eqos_start_clks(dev);
+		if (ret < 0) {
+			pr_err("eqos_start_clks() failed eqos_write_hwaddr failed : %d", ret);
+			return 0;
+		} else {
+			stop_clocks = 1;
+		}
+	}
 	/*
 	 * This function may be called before start() or after stop(). At that
 	 * time, on at least some configurations of the EQoS HW, all clocks to
@@ -705,6 +715,9 @@ static int eqos_write_hwaddr(struct udevice *dev)
 		(plat->enetaddr[0]);
 	writel(val, &eqos->mac_regs->address0_low);
 
+	if (stop_clocks)
+		ret = eqos->config->ops->eqos_stop_clks(dev);
+	
 	return 0;
 }
 
diff --git a/drivers/net/dwc_eth_qos_imx.c b/drivers/net/dwc_eth_qos_imx.c
index 8976b2ed06a..b8a043dccfd 100644
--- a/drivers/net/dwc_eth_qos_imx.c
+++ b/drivers/net/dwc_eth_qos_imx.c
@@ -210,7 +210,7 @@ static int eqos_get_enetaddr_imx(struct udevice *dev)
 {
 	struct eth_pdata *pdata = dev_get_plat(dev);
 
-	imx_get_mac_from_fuse(dev_seq(dev), pdata->enetaddr);
+	board_get_mac(dev_seq(dev), pdata->enetaddr);
 
 	return 0;
 }
diff --git a/drivers/net/fec_mxc.c b/drivers/net/fec_mxc.c
index 8a866ca8b79..08187911614 100644
--- a/drivers/net/fec_mxc.c
+++ b/drivers/net/fec_mxc.c
@@ -394,9 +394,14 @@ static void fec_rbd_clean(int last, struct fec_bd *prbd)
 	writew(0, &prbd->data_length);
 }
 
+__weak int board_get_mac(int dev_id, unsigned char *mac)
+{
+	return -EOPNOTSUPP;
+};
+
 static int fec_get_hwaddr(int dev_id, unsigned char *mac)
 {
-	imx_get_mac_from_fuse(dev_id, mac);
+	board_get_mac(dev_id, mac);
 	return !is_valid_ethaddr(mac);
 }
 
diff --git a/drivers/net/phy/phy.c b/drivers/net/phy/phy.c
index 63b3e46f101..0c3488fc58a 100644
--- a/drivers/net/phy/phy.c
+++ b/drivers/net/phy/phy.c
@@ -427,6 +427,11 @@ int genphy_config(struct phy_device *phydev)
 			features |= SUPPORTED_1000baseX_Half;
 	}
 
+	/* disable power-down */
+	val = phy_read(phydev, MDIO_DEVAD_NONE, MII_BMCR);
+	if (val & BMCR_PDOWN)
+		phy_write(phydev, MDIO_DEVAD_NONE, MII_BMCR, val ^ BMCR_PDOWN);
+
 	phydev->supported &= features;
 	phydev->advertising &= features;
 
diff --git a/include/configs/imx8mp_solidrun.h b/include/configs/imx8mp_solidrun.h
index 9d34c54d66d..a6ffb995d8c 100644
--- a/include/configs/imx8mp_solidrun.h
+++ b/include/configs/imx8mp_solidrun.h
@@ -3,8 +3,8 @@
  * Copyright 2019 NXP
  */
 
-#ifndef __IMX8MP_EVK_H
-#define __IMX8MP_EVK_H
+#ifndef __IMX8MP_SOLIDRUN_H
+#define __IMX8MP_SOLIDRUN_H
 
 #include <linux/sizes.h>
 #include <linux/stringify.h>
@@ -13,35 +13,52 @@
 
 #define CFG_SYS_UBOOT_BASE	(QSPI0_AMBA_BASE + CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_SECTOR * 512)
 
+#if defined(CONFIG_NAND_BOOT)
+#define CONFIG_SPL_NAND_BASE
+#define CONFIG_SPL_NAND_IDENT
+#define CONFIG_SYS_NAND_U_BOOT_OFFS 	0x4000000 /* Put the FIT out of first 64MB boot area */
+
+/* Set a redundant offset in nand FIT mtdpart. The new uuu will burn full boot image (not only FIT part) to the mtdpart, so we check both two offsets */
+#define CONFIG_SYS_NAND_U_BOOT_OFFS_REDUND \
+	(CONFIG_SYS_NAND_U_BOOT_OFFS + CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_SECTOR * 512 - 0x8400)
+#endif
+
+#define CONFIG_SERIAL_TAG
+#define CONFIG_FASTBOOT_USB_DEV 0
+
 #if defined(CONFIG_CMD_NET)
+
+// OMAR: TODO not sure what this value should be for this board
 #define CFG_FEC_MXC_PHYADDR          1
 
+// OMAR: TODO this is being moved to Kconfig https://github.com/trini/u-boot/commit/66103759595b1db6fb7355f95eca8af2334c4749
 #define PHY_ANEG_TIMEOUT 20000
 
 #endif
 
 #ifdef CONFIG_DISTRO_DEFAULTS
 #define BOOT_TARGET_DEVICES(func) \
-	func(USB, usb, 0) \
-	func(MMC, mmc, 1) \
-	func(MMC, mmc, 2)
+        func(MMC, mmc, 1) \
+        func(MMC, mmc, 2) \
+        func(USB, usb, 0) \
+        func(PXE, pxe, na) \
+        func(DHCP, dhcp, na)
 
 #include <config_distro_bootcmd.h>
 #else
 #define BOOTENV
 #endif
 
-#define JH_ROOT_DTB    "imx8mp-evk-root.dtb"
+#define JH_ROOT_DTB    "imx8mp-hummingboard-pulse-root.dtb"
 
 #define JAILHOUSE_ENV \
 	"jh_clk= \0 " \
-	"jh_root_dtb=" JH_ROOT_DTB "\0" \
-	"jh_mmcboot=setenv fdtfile ${jh_root_dtb};" \
-		"setenv jh_clk clk_ignore_unused mem=1920MB; " \
+	"jh_mmcboot=setenv fdtfile imx8mp-evk-root.dtb;" \
+		"setenv jh_clk clk_ignore_unusedmem=2048MB; " \
 			   "if run loadimage; then " \
 				   "run mmcboot; " \
 			   "else run jh_netboot; fi; \0" \
-	"jh_netboot=setenv fdtfile ${jh_root_dtb}; setenv jh_clk clk_ignore_unused mem=1920MB; run netboot; \0 "
+	"jh_netboot=setenv fdtfile ${jh_root_dtb}; setenv jh_clk clk_ignore_unused mem=2048MB; run netboot; \0 "
 
 #define SR_IR_V2_COMMAND \
 	"nodes=/busfreq /power-domains /soc@0/caam-sm@100000 /soc@0/bus@30000000/caam_secvio /soc@0/bus@30000000/caam-snvs@30370000 /soc@0/bus@30800000/flexspi_nand@30bb0000 /soc@0/bus@32c00000/mipi_dsi@32e60000 /soc@0/bus@32c00000/lcd-controller@32e80000 /soc@0/bus@32c00000/blk-ctl@32ec0000 /soc@0/bus@30800000/i2c@30a20000/pca9450@25 /soc@0/bus@30800000/i2c@30a30000/adv7535@3d /soc@0/bus@30800000/i2c@30a30000/tcpc@50 /wdt-reboot /mcu_rdc /soc@0/bus@30800000/ethernet@30bf0000 /dsi-host /rm67199_panel /cbtl04gp /binman /vpu_g1@38300000 /vpu_g2@38310000 /vpu_vc8000e@38320000 /vpu_v4l2 /gpu3d@38000000 /gpu2d@38008000 /vipsi@38500000 /mix_gpu_ml \0" \
@@ -58,30 +78,7 @@
 	"emmc_dev=2\0"\
 	"sd_dev=1\0"
 
-
-#ifdef CONFIG_NAND_BOOT
-#define MFG_NAND_PARTITION "mtdparts=gpmi-nand:64m(nandboot),16m(nandfit),64m(nandkernel),16m(nanddtb),8m(nandtee),-(nandrootfs)"
-#endif
-
-/* Initial environment variables */
-#if defined(CONFIG_NAND_BOOT)
-#define CFG_EXTRA_ENV_SETTINGS \
-	CFG_MFG_ENV_SETTINGS \
-	"splashimage=0x50000000\0" \
-	"fdt_addr_r=0x43000000\0"			\
-	"fdt_addr=0x43000000\0"			\
-	"fdt_high=0xffffffffffffffff\0" \
-	"mtdparts=" MFG_NAND_PARTITION "\0" \
-	"console=ttymxc1,115200 earlycon=ec_imx6q,0x30890000,115200\0" \
-	"bootargs=console=ttymxc1,115200 earlycon=ec_imx6q,0x30890000,115200 ubi.mtd=nandrootfs "  \
-		"root=ubi0:nandrootfs rootfstype=ubifs "		     \
-		MFG_NAND_PARTITION \
-		"\0" \
-	"bootcmd=nand read ${loadaddr} 0x5000000 0x4000000;"\
-		"nand read ${fdt_addr_r} 0x9000000 0x100000;"\
-		"booti ${loadaddr} - ${fdt_addr_r}"
-
-#else
+// TODO: omar remove fdtfile here?
 #define CFG_EXTRA_ENV_SETTINGS		\
 	CFG_MFG_ENV_SETTINGS \
 	JAILHOUSE_ENV \
@@ -153,34 +150,36 @@
 			   "fi; " \
 		   "fi; " \
 	   "fi;"
-#endif
 
 /* Link Definitions */
 
 #define CFG_SYS_INIT_RAM_ADDR	0x40000000
 #define CFG_SYS_INIT_RAM_SIZE	0x80000
 
-
 /* Totally 6GB DDR */
 #define CFG_SYS_SDRAM_BASE		0x40000000
-#define PHYS_SDRAM			0x40000000
+#define PHYS_SDRAM				0x40000000
 #define PHYS_SDRAM_SIZE			0xC0000000	/* 3 GB */
 #define PHYS_SDRAM_2			0x100000000
-#ifdef CONFIG_TARGET_IMX8MP_DDR4_EVK
-#define PHYS_SDRAM_2_SIZE		0x40000000	/* 1 GB */
-#else
-#define PHYS_SDRAM_2_SIZE		0xC0000000	/* 3 GB */
-#endif
 
+/* Some general LPDDR4 macros */
+#define LPDDR4_SAMSUNG_MANID		0x1
+
+// OMAR: TODO is this even necessary anymore?
+// https://github.com/trini/u-boot/commit/0e1b54247d7e3e69e0af5c4dc7a3b26acf9e8451
 #define CFG_MXC_UART_BASE		UART2_BASE_ADDR
+// #define CFG_MXC_UART_BASE		UART_BASE_ADDR(2)
 
 #define CFG_SYS_NAND_BASE           0x20000000
 
-#ifdef CONFIG_TARGET_IMX8MP_DDR4_EVK
-#define CFG_SYS_FSL_USDHC_NUM	1
-#else
-#define CFG_SYS_FSL_USDHC_NUM	2
-#endif
+// OMAR: https://github.com/trini/u-boot/commit/42d56cad6395528e09c00b65643953bad7b9f793
+// #define CFG_SYS_FSL_USDHC_NUM	2
+// #define CFG_SYS_FSL_ESDHC_ADDR	0
+
+/* USB configs */
+#define CONFIG_USB_MAX_CONTROLLER_COUNT         2
+#define CONFIG_USBD_HS
+#define CONFIG_USB_GADGET_VBUS_DRAW 2
 
 #ifdef CONFIG_ANDROID_SUPPORT
 #include "imx8mp_evk_android.h"
diff --git a/include/tlv_eeprom.h b/include/tlv_eeprom.h
index 2b1e19b2bdd..2779f8d2c59 100644
--- a/include/tlv_eeprom.h
+++ b/include/tlv_eeprom.h
@@ -26,11 +26,11 @@ struct __attribute__ ((__packed__)) tlvinfo_header {
 };
 
 // Header Field Constants
+#define TLV_INFO_HEADER_SIZE    sizeof(struct tlvinfo_header)
 #define TLV_INFO_ID_STRING      "TlvInfo"
 #define TLV_INFO_VERSION        0x01
 #define TLV_INFO_MAX_LEN        2048
-#define TLV_TOTAL_LEN_MAX       (TLV_INFO_MAX_LEN - \
-				sizeof(struct tlvinfo_header))
+#define TLV_TOTAL_LEN_MAX       (TLV_INFO_MAX_LEN - TLV_INFO_HEADER_SIZE)
 
 /*
  * TlvInfo TLV: Layout of a TLV field
@@ -41,6 +41,7 @@ struct __attribute__ ((__packed__)) tlvinfo_tlv {
 	u8  value[0];
 };
 
+#define TLV_INFO_ENTRY_SIZE      sizeof(struct tlvinfo_tlv)
 /* Maximum length of a TLV value in bytes */
 #define TLV_VALUE_MAX_LEN        255
 
@@ -67,7 +68,15 @@ struct __attribute__ ((__packed__)) tlvinfo_tlv {
 #define TLV_CODE_VENDOR_EXT     0xFD
 #define TLV_CODE_CRC_32         0xFE
 
-#if CONFIG_IS_ENABLED(CMD_TLV_EEPROM)
+/* how many EEPROMs can be used */
+#define TLV_MAX_DEVICES			2
+
+/**
+ * Check whether eeprom device exists.
+ *
+ * @dev: EEPROM device to check.
+ */
+bool exists_tlv_eeprom(int dev);
 
 /**
  * read_tlv_eeprom - Read the EEPROM binary data from the hardware
@@ -113,26 +122,86 @@ int write_tlv_eeprom(void *eeprom, int len, int dev);
 int read_tlvinfo_tlv_eeprom(void *eeprom, struct tlvinfo_header **hdr,
 			    struct tlvinfo_tlv **first_entry, int dev);
 
-#else /* !CONFIG_IS_ENABLED(CMD_TLV_EEPROM) */
+/**
+ * Write TLV data to the EEPROM.
+ *
+ * - Only writes length of actual tlv data
+ * - updates checksum
+ *
+ * @eeprom: Pointer to buffer to hold the binary data. Must point to a buffer
+ *          of size at least TLV_INFO_MAX_LEN.
+ * @dev   : EEPROM device to write
+ *
+ */
+int write_tlvinfo_tlv_eeprom(void *eeprom, int dev);
 
-static inline int read_tlv_eeprom(void *eeprom, int offset, int len, int dev)
-{
-	return -ENOSYS;
-}
+/**
+ *  tlvinfo_find_tlv
+ *
+ *  This function finds the TLV with the supplied code in the EERPOM.
+ *  An offset from the beginning of the EEPROM is returned in the
+ *  eeprom_index parameter if the TLV is found.
+ */
+bool tlvinfo_find_tlv(u8 *eeprom, u8 tcode, int *eeprom_index);
 
-static inline int write_tlv_eeprom(void *eeprom, int len)
-{
-	return -ENOSYS;
-}
+/**
+ *  tlvinfo_add_tlv
+ *
+ *  This function adds a TLV to the EEPROM, converting the value (a string) to
+ *  the format in which it will be stored in the EEPROM.
+ * @eeprom: Pointer to buffer to hold the binary data. Must point to a buffer
+ *          of size at least TLV_INFO_MAX_LEN.
+ * @code The TLV Code for the new entry.
+ * @eeprom_index success offset into EEPROM where the new entry has been stored
+ *
+ */
+bool tlvinfo_add_tlv(u8 *eeprom, int code, char *strval);
 
-static inline int
-read_tlvinfo_tlv_eeprom(void *eeprom, struct tlvinfo_header **hdr,
-			struct tlvinfo_tlv **first_entry, int dev)
-{
-	return -ENOSYS;
-}
+/**
+ *  tlvinfo_delete_tlv
+ *
+ *  This function deletes the TLV with the specified type code from the
+ *  EEPROM.
+ * @eeprom: Pointer to buffer to hold the binary data. Must point to a buffer
+ *          of size at least TLV_INFO_MAX_LEN.
+ * @code The TLV Code of the entry to delete.
+ */
+bool tlvinfo_delete_tlv(u8 *eeprom, u8 code);
 
-#endif /* CONFIG_IS_ENABLED(CMD_TLV_EEPROM) */
+/**
+ * Read the TLV entry with specified code to a buffer as terminated C string.
+ * @eeprom: Pointer to buffer holding the TLV EEPROM binary data.
+ * @code:   The TLV Code of the entry to read.
+ * @buffer: Pointer to buffer where the value will be stored. Must have capacity
+ *          for the string representation of the data including null terminator.
+ * @length: size of the buffer where the value will be stored.
+ *
+ * Return length of string on success, -1 on error.
+ */
+ssize_t tlvinfo_read_tlv(u8 *eeprom, u8 code, u8 *buffer, size_t length);
+
+/**
+ *  tlvinfo_update_crc
+ *
+ *  This function updates the CRC-32 TLV. If there is no CRC-32 TLV, then
+ *  one is added. This function should be called after each update to the
+ *  EEPROM structure, to make sure the CRC is always correct.
+ *
+ * @eeprom: Pointer to buffer to hold the binary data. Must point to a buffer
+ *          of size at least TLV_INFO_MAX_LEN.
+ */
+void tlvinfo_update_crc(u8 *eeprom);
+
+/**
+ *  Validate the checksum in the provided TlvInfo EEPROM data. First,
+ *  verify that the TlvInfo header is valid, then make sure the last
+ *  TLV is a CRC-32 TLV. Then calculate the CRC over the EEPROM data
+ *  and compare it to the value stored in the EEPROM CRC-32 TLV.
+ *
+ * @eeprom: Pointer to buffer to hold the binary data. Must point to a buffer
+ *          of size at least TLV_INFO_MAX_LEN.
+ */
+bool tlvinfo_check_crc(u8 *eeprom);
 
 /**
  *  is_valid_tlvinfo_header
@@ -152,4 +221,16 @@ static inline bool is_valid_tlvinfo_header(struct tlvinfo_header *hdr)
 		(be16_to_cpu(hdr->totallen) <= TLV_TOTAL_LEN_MAX));
 }
 
+/**
+ *  is_valid_tlv
+ *
+ *  Perform basic sanity checks on a TLV field. The TLV is pointed to
+ *  by the parameter provided.
+ *      1. The type code is not reserved (0x00 or 0xFF)
+ */
+static inline bool is_valid_tlvinfo_entry(struct tlvinfo_tlv *tlv)
+{
+	return((tlv->type != 0x00) && (tlv->type != 0xFF));
+}
+
 #endif /* __TLV_EEPROM_H_ */
diff --git a/lib/Kconfig b/lib/Kconfig
index effaffe355d..65ff934f4e7 100644
--- a/lib/Kconfig
+++ b/lib/Kconfig
@@ -1200,3 +1200,4 @@ config PHANDLE_CHECK_SEQ
 endmenu
 
 source lib/fwu_updates/Kconfig
+source lib/tlv/Kconfig
diff --git a/lib/Makefile b/lib/Makefile
index e6b6a9e0aab..1401d89f181 100644
--- a/lib/Makefile
+++ b/lib/Makefile
@@ -96,6 +96,8 @@ obj-$(CONFIG_AVB_SUPPORT) += avb/
 obj-$(CONFIG_$(SPL_TPL_)OF_LIBFDT) += libfdt/
 obj-$(CONFIG_$(SPL_TPL_)OF_REAL) += fdtdec_common.o fdtdec.o
 
+obj-$(CONFIG_EEPROM_TLV_LIB) += tlv/
+
 ifdef CONFIG_SPL_BUILD
 obj-$(CONFIG_SPL_YMODEM_SUPPORT) += crc16-ccitt.o
 obj-$(CONFIG_$(SPL_TPL_)HASH) += crc16-ccitt.o
diff --git a/lib/tlv/Kconfig b/lib/tlv/Kconfig
new file mode 100644
index 00000000000..b0cf63fbee7
--- /dev/null
+++ b/lib/tlv/Kconfig
@@ -0,0 +1,16 @@
+config EEPROM_TLV_LIB
+	bool "Enable EEPROM TLV library"
+	depends on I2C_EEPROM
+	help
+	  Selecting this option will enable the shared EEPROM TLV library code.
+	  It provides functions for reading, writing and parsing of
+	  TLV-encoded data from EEPROMs.
+
+config SPL_EEPROM_TLV_LIB
+	bool "Enable EEPROM TLV library for SPL"
+    select EEPROM_TLV_LIB
+	depends on SPL_I2C_EEPROM
+	help
+	  Selecting this option will enable the shared EEPROM TLV library code.
+	  It provides functions for reading, writing and parsing of
+	  TLV-encoded data from EEPROMs.
diff --git a/lib/tlv/Makefile b/lib/tlv/Makefile
new file mode 100644
index 00000000000..8e96752e75c
--- /dev/null
+++ b/lib/tlv/Makefile
@@ -0,0 +1,5 @@
+# SPDX-License-Identifier: GPL-2.0+
+#
+# (C) Copyright 2017 Linaro
+
+obj-$(CONFIG_EEPROM_TLV_LIB) += tlv_eeprom.o
diff --git a/lib/tlv/tlv_eeprom.c b/lib/tlv/tlv_eeprom.c
new file mode 100644
index 00000000000..2fbc97126cf
--- /dev/null
+++ b/lib/tlv/tlv_eeprom.c
@@ -0,0 +1,778 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * Copyright (C) 2013 Curt Brune <curt@cumulusnetworks.com>
+ * Copyright (C) 2014 Srideep <srideep_devireddy@dell.com>
+ * Copyright (C) 2013 Miles Tseng <miles_tseng@accton.com>
+ * Copyright (C) 2014,2016 david_yang <david_yang@accton.com>
+ * Copyright (C) 2022 Josua Mayer <josua@solid-run.com>
+ */
+
+#include <common.h>
+#include <command.h>
+#include <dm.h>
+#include <i2c.h>
+#include <i2c_eeprom.h>
+#include <env.h>
+#include <init.h>
+#include <net.h>
+#include <asm/global_data.h>
+#include <linux/ctype.h>
+#include <u-boot/crc.h>
+
+#include "tlv_eeprom.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+/* File scope function prototypes */
+static int read_eeprom(int devnum, u8 *eeprom);
+static int set_mac(char *buf, const char *string);
+static int set_date(char *buf, const char *string);
+static int set_bytes(char *buf, const char *string, int *converted_accum);
+
+/* The EERPOM contents after being read into memory */
+static u8 eeprom[TLV_INFO_MAX_LEN];
+
+static struct udevice *tlv_devices[TLV_MAX_DEVICES];
+
+#define to_header(p) ((struct tlvinfo_header *)p)
+#define to_entry(p) ((struct tlvinfo_tlv *)p)
+
+/**
+ * Check whether eeprom device exists.
+ */
+bool exists_tlv_eeprom(int dev)
+{
+	return dev < TLV_MAX_DEVICES && tlv_devices[dev] != 0;
+}
+
+static inline bool is_digit(char c)
+{
+	return (c >= '0' && c <= '9');
+}
+
+/**
+ *  is_hex
+ *
+ *  Tests if character is an ASCII hex digit
+ */
+static inline u8 is_hex(char p)
+{
+	return (((p >= '0') && (p <= '9')) ||
+		((p >= 'A') && (p <= 'F')) ||
+		((p >= 'a') && (p <= 'f')));
+}
+
+/**
+ *  Validate the checksum in the provided TlvInfo EEPROM data. First,
+ *  verify that the TlvInfo header is valid, then make sure the last
+ *  TLV is a CRC-32 TLV. Then calculate the CRC over the EEPROM data
+ *  and compare it to the value stored in the EEPROM CRC-32 TLV.
+ */
+bool tlvinfo_check_crc(u8 *eeprom)
+{
+	struct tlvinfo_header *eeprom_hdr = to_header(eeprom);
+	struct tlvinfo_tlv    *eeprom_crc;
+	unsigned int       calc_crc;
+	unsigned int       stored_crc;
+
+	// Is the eeprom header valid?
+	if (!is_valid_tlvinfo_header(eeprom_hdr))
+		return false;
+
+	// Is the last TLV a CRC?
+	eeprom_crc = to_entry(&eeprom[TLV_INFO_HEADER_SIZE +
+		be16_to_cpu(eeprom_hdr->totallen) - (TLV_INFO_ENTRY_SIZE + 4)]);
+	if (eeprom_crc->type != TLV_CODE_CRC_32 || eeprom_crc->length != 4)
+		return false;
+
+	// Calculate the checksum
+	calc_crc = crc32(0, (void *)eeprom,
+			 TLV_INFO_HEADER_SIZE + be16_to_cpu(eeprom_hdr->totallen) - 4);
+	stored_crc = (eeprom_crc->value[0] << 24) |
+		(eeprom_crc->value[1] << 16) |
+		(eeprom_crc->value[2] <<  8) |
+		eeprom_crc->value[3];
+	return calc_crc == stored_crc;
+}
+
+/**
+ *  read_eeprom
+ *
+ *  Read the EEPROM into memory, if it hasn't already been read.
+ */
+static int read_eeprom(int devnum, u8 *eeprom)
+{
+	int ret;
+	struct tlvinfo_header *eeprom_hdr = to_header(eeprom);
+	struct tlvinfo_tlv *eeprom_tlv = to_entry(&eeprom[TLV_INFO_HEADER_SIZE]);
+
+	/* Read the header */
+	ret = read_tlv_eeprom((void *)eeprom_hdr, 0, TLV_INFO_HEADER_SIZE, devnum);
+	/* If the header was successfully read, read the TLVs */
+	if (ret == 0 && is_valid_tlvinfo_header(eeprom_hdr))
+		ret = read_tlv_eeprom((void *)eeprom_tlv, TLV_INFO_HEADER_SIZE,
+				      be16_to_cpu(eeprom_hdr->totallen), devnum);
+	else if (ret == -ENODEV)
+		return ret;
+
+	// If the contents are invalid, start over with default contents
+	if (!is_valid_tlvinfo_header(eeprom_hdr) ||
+	    !tlvinfo_check_crc(eeprom)) {
+		strcpy(eeprom_hdr->signature, TLV_INFO_ID_STRING);
+		eeprom_hdr->version = TLV_INFO_VERSION;
+		eeprom_hdr->totallen = cpu_to_be16(0);
+		tlvinfo_update_crc(eeprom);
+	}
+
+#ifdef DEBUG
+	show_eeprom(devnum, eeprom);
+#endif
+
+	return ret;
+}
+
+
+/**
+ *  tlvinfo_update_crc
+ *
+ *  This function updates the CRC-32 TLV. If there is no CRC-32 TLV, then
+ *  one is added. This function should be called after each update to the
+ *  EEPROM structure, to make sure the CRC is always correct.
+ */
+void tlvinfo_update_crc(u8 *eeprom)
+{
+	struct tlvinfo_header *eeprom_hdr = to_header(eeprom);
+	struct tlvinfo_tlv    *eeprom_crc;
+	unsigned int      calc_crc;
+	int               eeprom_index;
+
+	// Discover the CRC TLV
+	if (!tlvinfo_find_tlv(eeprom, TLV_CODE_CRC_32, &eeprom_index)) {
+		unsigned int totallen = be16_to_cpu(eeprom_hdr->totallen);
+
+		if ((totallen + TLV_INFO_ENTRY_SIZE + 4) > TLV_TOTAL_LEN_MAX)
+			return;
+		eeprom_index = TLV_INFO_HEADER_SIZE + totallen;
+		eeprom_hdr->totallen = cpu_to_be16(totallen + TLV_INFO_ENTRY_SIZE + 4);
+	}
+	eeprom_crc = to_entry(&eeprom[eeprom_index]);
+	eeprom_crc->type = TLV_CODE_CRC_32;
+	eeprom_crc->length = 4;
+
+	// Calculate the checksum
+	calc_crc = crc32(0, (void *)eeprom,
+			 TLV_INFO_HEADER_SIZE + be16_to_cpu(eeprom_hdr->totallen) - 4);
+	eeprom_crc->value[0] = (calc_crc >> 24) & 0xFF;
+	eeprom_crc->value[1] = (calc_crc >> 16) & 0xFF;
+	eeprom_crc->value[2] = (calc_crc >>  8) & 0xFF;
+	eeprom_crc->value[3] = (calc_crc >>  0) & 0xFF;
+}
+
+/**
+ *  write_tlvinfo_tlv_eeprom
+ *
+ *  Write the TLV data from CPU memory to the hardware.
+ */
+int write_tlvinfo_tlv_eeprom(void *eeprom, int dev)
+{
+	int ret = 0;
+	struct tlvinfo_header *eeprom_hdr = to_header(eeprom);
+	int eeprom_len;
+
+	tlvinfo_update_crc(eeprom);
+
+	eeprom_len = TLV_INFO_HEADER_SIZE + be16_to_cpu(eeprom_hdr->totallen);
+	ret = write_tlv_eeprom(eeprom, eeprom_len, devnum);
+	if (ret) {
+		printf("Programming failed.\n");
+		return -1;
+	}
+
+	printf("Programming passed.\n");
+	return 0;
+}
+
+/**
+ *  tlvinfo_find_tlv
+ *
+ *  This function finds the TLV with the supplied code in the EERPOM.
+ *  An offset from the beginning of the EEPROM is returned in the
+ *  eeprom_index parameter if the TLV is found.
+ */
+bool tlvinfo_find_tlv(u8 *eeprom, u8 tcode, int *eeprom_index)
+{
+	struct tlvinfo_header *eeprom_hdr = to_header(eeprom);
+	struct tlvinfo_tlv    *eeprom_tlv;
+	int eeprom_end;
+
+	// Search through the TLVs, looking for the first one which matches the
+	// supplied type code.
+	*eeprom_index = TLV_INFO_HEADER_SIZE;
+	eeprom_end = TLV_INFO_HEADER_SIZE + be16_to_cpu(eeprom_hdr->totallen);
+	while (*eeprom_index < eeprom_end) {
+		eeprom_tlv = to_entry(&eeprom[*eeprom_index]);
+		if (!is_valid_tlvinfo_entry(eeprom_tlv))
+			return false;
+		if (eeprom_tlv->type == tcode)
+			return true;
+		*eeprom_index += TLV_INFO_ENTRY_SIZE + eeprom_tlv->length;
+	}
+	return(false);
+}
+
+/**
+ *  tlvinfo_delete_tlv
+ *
+ *  This function deletes the TLV with the specified type code from the
+ *  EEPROM.
+ */
+bool tlvinfo_delete_tlv(u8 *eeprom, u8 code)
+{
+	int eeprom_index;
+	int tlength;
+	struct tlvinfo_header *eeprom_hdr = to_header(eeprom);
+	struct tlvinfo_tlv *eeprom_tlv;
+
+	// Find the TLV and then move all following TLVs "forward"
+	if (tlvinfo_find_tlv(eeprom, code, &eeprom_index)) {
+		eeprom_tlv = to_entry(&eeprom[eeprom_index]);
+		tlength = TLV_INFO_ENTRY_SIZE + eeprom_tlv->length;
+		memcpy(&eeprom[eeprom_index], &eeprom[eeprom_index + tlength],
+		       TLV_INFO_HEADER_SIZE +
+		       be16_to_cpu(eeprom_hdr->totallen) - eeprom_index -
+		       tlength);
+		eeprom_hdr->totallen =
+			cpu_to_be16(be16_to_cpu(eeprom_hdr->totallen) -
+				    tlength);
+		tlvinfo_update_crc(eeprom);
+		return true;
+	}
+	return false;
+}
+
+/**
+ *  tlvinfo_add_tlv
+ *
+ *  This function adds a TLV to the EEPROM, converting the value (a string) to
+ *  the format in which it will be stored in the EEPROM.
+ */
+#define MAX_TLV_VALUE_LEN   256
+bool tlvinfo_add_tlv(u8 *eeprom, int tcode, char *strval)
+{
+	struct tlvinfo_header *eeprom_hdr = to_header(eeprom);
+	struct tlvinfo_tlv *eeprom_tlv;
+	int new_tlv_len = 0;
+	u32 value;
+	char data[MAX_TLV_VALUE_LEN];
+	int eeprom_index;
+
+	// Encode each TLV type into the format to be stored in the EERPOM
+	switch (tcode) {
+	case TLV_CODE_PRODUCT_NAME:
+	case TLV_CODE_PART_NUMBER:
+	case TLV_CODE_SERIAL_NUMBER:
+	case TLV_CODE_LABEL_REVISION:
+	case TLV_CODE_PLATFORM_NAME:
+	case TLV_CODE_ONIE_VERSION:
+	case TLV_CODE_MANUF_NAME:
+	case TLV_CODE_MANUF_COUNTRY:
+	case TLV_CODE_VENDOR_NAME:
+	case TLV_CODE_DIAG_VERSION:
+	case TLV_CODE_SERVICE_TAG:
+		strncpy(data, strval, MAX_TLV_VALUE_LEN);
+		new_tlv_len = min_t(size_t, MAX_TLV_VALUE_LEN, strlen(strval));
+		break;
+	case TLV_CODE_DEVICE_VERSION:
+		value = simple_strtoul(strval, NULL, 0);
+		if (value >= 256) {
+			printf("ERROR: Device version must be 255 or less. Value supplied: %u",
+			       value);
+			return false;
+		}
+		data[0] = value & 0xFF;
+		new_tlv_len = 1;
+		break;
+	case TLV_CODE_MAC_SIZE:
+		value = simple_strtoul(strval, NULL, 0);
+		if (value >= 65536) {
+			printf("ERROR: MAC Size must be 65535 or less. Value supplied: %u",
+			       value);
+			return false;
+		}
+		data[0] = (value >> 8) & 0xFF;
+		data[1] = value & 0xFF;
+		new_tlv_len = 2;
+		break;
+	case TLV_CODE_MANUF_DATE:
+		if (set_date(data, strval) != 0)
+			return false;
+		new_tlv_len = 19;
+		break;
+	case TLV_CODE_MAC_BASE:
+		if (set_mac(data, strval) != 0)
+			return false;
+		new_tlv_len = 6;
+		break;
+	case TLV_CODE_CRC_32:
+		printf("WARNING: The CRC TLV is set automatically and cannot be set manually.\n");
+		return false;
+	case TLV_CODE_VENDOR_EXT:
+	default:
+		if (set_bytes(data, strval, &new_tlv_len) != 0)
+			return false;
+		break;
+	}
+
+	// Is there room for this TLV?
+	if ((be16_to_cpu(eeprom_hdr->totallen) + TLV_INFO_ENTRY_SIZE + new_tlv_len) >
+			TLV_TOTAL_LEN_MAX) {
+		printf("ERROR: There is not enough room in the EERPOM to save data.\n");
+		return false;
+	}
+
+	// Add TLV at the end, overwriting CRC TLV if it exists
+	if (tlvinfo_find_tlv(eeprom, TLV_CODE_CRC_32, &eeprom_index))
+		eeprom_hdr->totallen =
+			cpu_to_be16(be16_to_cpu(eeprom_hdr->totallen) -
+					TLV_INFO_ENTRY_SIZE - 4);
+	else
+		eeprom_index = TLV_INFO_HEADER_SIZE + be16_to_cpu(eeprom_hdr->totallen);
+	eeprom_tlv = to_entry(&eeprom[eeprom_index]);
+	eeprom_tlv->type = tcode;
+	eeprom_tlv->length = new_tlv_len;
+	memcpy(eeprom_tlv->value, data, new_tlv_len);
+
+	// Update the total length and calculate (add) a new CRC-32 TLV
+	eeprom_hdr->totallen = cpu_to_be16(be16_to_cpu(eeprom_hdr->totallen) +
+			TLV_INFO_ENTRY_SIZE + new_tlv_len);
+	tlvinfo_update_crc(eeprom);
+
+	return true;
+}
+
+/**
+ * Read the TLV entry with specified code to a buffer as terminated C string.
+ */
+ssize_t tlvinfo_read_tlv(u8 *eeprom, u8 code, u8 *buffer, size_t length)
+{
+	int index;
+	struct tlvinfo_tlv *tlv;
+
+	// read sku from part-number field
+	if (tlvinfo_find_tlv(eeprom, code, &index)) {
+		tlv = (struct tlvinfo_tlv *)&eeprom[index];
+		if (tlv->length > length) {
+			pr_err("%s: tlv value (%d) larger than buffer (%zu)!\n",
+			       __func__, tlv->length + 1, length);
+			return -1;
+		}
+		memcpy(buffer, tlv->value, tlv->length);
+		buffer[tlv->length] = 0;
+
+		return tlv->length;
+	}
+
+	return -1;
+}
+
+/**
+ *  set_mac
+ *
+ *  Converts a string MAC address into a binary buffer.
+ *
+ *  This function takes a pointer to a MAC address string
+ *  (i.e."XX:XX:XX:XX:XX:XX", where "XX" is a two-digit hex number).
+ *  The string format is verified and then converted to binary and
+ *  stored in a buffer.
+ */
+static int set_mac(char *buf, const char *string)
+{
+	char *p = (char *)string;
+	int   i;
+	int   err = 0;
+	char *end;
+
+	if (!p) {
+		printf("ERROR: NULL mac addr string passed in.\n");
+		return -1;
+	}
+
+	if (strlen(p) != 17) {
+		printf("ERROR: MAC address strlen() != 17 -- %zu\n", strlen(p));
+		printf("ERROR: Bad MAC address format: %s\n", string);
+		return -1;
+	}
+
+	for (i = 0; i < 17; i++) {
+		if ((i % 3) == 2) {
+			if (p[i] != ':') {
+				err++;
+				printf("ERROR: mac: p[%i] != :, found: `%c'\n",
+				       i, p[i]);
+				break;
+			}
+			continue;
+		} else if (!is_hex(p[i])) {
+			err++;
+			printf("ERROR: mac: p[%i] != hex digit, found: `%c'\n",
+			       i, p[i]);
+			break;
+		}
+	}
+
+	if (err != 0) {
+		printf("ERROR: Bad MAC address format: %s\n", string);
+		return -1;
+	}
+
+	/* Convert string to binary */
+	for (i = 0, p = (char *)string; i < 6; i++) {
+		buf[i] = p ? hextoul(p, &end) : 0;
+		if (p)
+			p = (*end) ? end + 1 : end;
+	}
+
+	if (!is_valid_ethaddr((u8 *)buf)) {
+		printf("ERROR: MAC address must not be 00:00:00:00:00:00, a multicast address or FF:FF:FF:FF:FF:FF.\n");
+		printf("ERROR: Bad MAC address format: %s\n", string);
+		return -1;
+	}
+
+	return 0;
+}
+
+/**
+ *  set_date
+ *
+ *  Validates the format of the data string
+ *
+ *  This function takes a pointer to a date string (i.e. MM/DD/YYYY hh:mm:ss)
+ *  and validates that the format is correct. If so the string is copied
+ *  to the supplied buffer.
+ */
+static int set_date(char *buf, const char *string)
+{
+	int i;
+
+	if (!string) {
+		printf("ERROR: NULL date string passed in.\n");
+		return -1;
+	}
+
+	if (strlen(string) != 19) {
+		printf("ERROR: Date strlen() != 19 -- %zu\n", strlen(string));
+		printf("ERROR: Bad date format (MM/DD/YYYY hh:mm:ss): %s\n",
+		       string);
+		return -1;
+	}
+
+	for (i = 0; string[i] != 0; i++) {
+		switch (i) {
+		case 2:
+		case 5:
+			if (string[i] != '/') {
+				printf("ERROR: Bad date format (MM/DD/YYYY hh:mm:ss): %s\n",
+				       string);
+				return -1;
+			}
+			break;
+		case 10:
+			if (string[i] != ' ') {
+				printf("ERROR: Bad date format (MM/DD/YYYY hh:mm:ss): %s\n",
+				       string);
+				return -1;
+			}
+			break;
+		case 13:
+		case 16:
+			if (string[i] != ':') {
+				printf("ERROR: Bad date format (MM/DD/YYYY hh:mm:ss): %s\n",
+				       string);
+				return -1;
+			}
+			break;
+		default:
+			if (!is_digit(string[i])) {
+				printf("ERROR: Bad date format (MM/DD/YYYY hh:mm:ss): %s\n",
+				       string);
+				return -1;
+			}
+			break;
+		}
+	}
+
+	strcpy(buf, string);
+	return 0;
+}
+
+/**
+ *  set_bytes
+ *
+ *  Converts a space-separated string of decimal numbers into a
+ *  buffer of bytes.
+ *
+ *  This function takes a pointer to a space-separated string of decimal
+ *  numbers (i.e. "128 0x55 0321") with "C" standard radix specifiers
+ *  and converts them to an array of bytes.
+ */
+static int set_bytes(char *buf, const char *string, int *converted_accum)
+{
+	char *p = (char *)string;
+	int   i;
+	uint  byte;
+
+	if (!p) {
+		printf("ERROR: NULL string passed in.\n");
+		return -1;
+	}
+
+	/* Convert string to bytes */
+	for (i = 0, p = (char *)string; (i < TLV_VALUE_MAX_LEN) && (*p != 0);
+			i++) {
+		while ((*p == ' ') || (*p == '\t') || (*p == ',') ||
+		       (*p == ';')) {
+			p++;
+		}
+		if (*p != 0) {
+			if (!is_digit(*p)) {
+				printf("ERROR: Non-digit found in byte string: (%s)\n",
+				       string);
+				return -1;
+			}
+			byte = simple_strtoul(p, &p, 0);
+			if (byte >= 256) {
+				printf("ERROR: The value specified is greater than 255: (%u) in string: %s\n",
+				       byte, string);
+				return -1;
+			}
+			buf[i] = byte & 0xFF;
+		}
+	}
+
+	if (i == TLV_VALUE_MAX_LEN && (*p != 0)) {
+		printf("ERROR: Trying to assign too many bytes (max: %d) in string: %s\n",
+		       TLV_VALUE_MAX_LEN, string);
+		return -1;
+	}
+
+	*converted_accum = i;
+	return 0;
+}
+
+static int find_tlv_devices(struct udevice **tlv_devices_p)
+{
+	int ret;
+	int count_dev = 0;
+	struct udevice *dev;
+
+	for (ret = uclass_first_device_check(UCLASS_I2C_EEPROM, &dev);
+			dev;
+			ret = uclass_next_device_check(&dev)) {
+		if (ret == 0)
+			tlv_devices_p[count_dev++] = dev;
+		if (count_dev >= TLV_MAX_DEVICES)
+			break;
+	}
+
+	return (count_dev == 0) ? -ENODEV : 0;
+}
+
+static struct udevice *find_tlv_device_by_index(int dev_num)
+{
+	struct udevice *local_tlv_devices[TLV_MAX_DEVICES] = {};
+	struct udevice **tlv_devices_p;
+	int ret;
+
+	if (gd->flags & (GD_FLG_RELOC | GD_FLG_SPL_INIT)) {
+		/* Assume BSS is initialized; use static data */
+		if (tlv_devices[dev_num])
+			return tlv_devices[dev_num];
+		tlv_devices_p = tlv_devices;
+	} else {
+		tlv_devices_p = local_tlv_devices;
+	}
+
+	ret = find_tlv_devices(tlv_devices_p);
+	if (ret == 0 && tlv_devices_p[dev_num])
+		return tlv_devices_p[dev_num];
+
+	return NULL;
+}
+
+/**
+ * read_tlv_eeprom - read the hwinfo from i2c EEPROM
+ */
+int read_tlv_eeprom(void *eeprom, int offset, int len, int dev_num)
+{
+	struct udevice *dev;
+
+	if (dev_num >= TLV_MAX_DEVICES)
+		return -EINVAL;
+
+	dev = find_tlv_device_by_index(dev_num);
+	if (!dev)
+		return -ENODEV;
+
+	return i2c_eeprom_read(dev, offset, eeprom, len);
+}
+
+/**
+ * write_tlv_eeprom - write the hwinfo to i2c EEPROM
+ */
+int write_tlv_eeprom(void *eeprom, int len, int dev)
+{
+	if (!(gd->flags & GD_FLG_RELOC))
+		return -ENODEV;
+	if (!tlv_devices[dev])
+		return -ENODEV;
+
+	return i2c_eeprom_write(tlv_devices[dev], 0, eeprom, len);
+}
+
+int read_tlvinfo_tlv_eeprom(void *eeprom, struct tlvinfo_header **hdr,
+			    struct tlvinfo_tlv **first_entry, int dev_num)
+{
+	int ret;
+	struct tlvinfo_header *tlv_hdr;
+	struct tlvinfo_tlv *tlv_ent;
+
+	/* Read TLV header */
+	ret = read_tlv_eeprom(eeprom, 0, TLV_INFO_HEADER_SIZE, dev_num);
+	if (ret < 0)
+		return ret;
+
+	tlv_hdr = eeprom;
+	if (!is_valid_tlvinfo_header(tlv_hdr))
+		return -EINVAL;
+
+	/* Read TLV entries */
+	tlv_ent = to_entry(&tlv_hdr[1]);
+	ret = read_tlv_eeprom(tlv_ent, TLV_INFO_HEADER_SIZE,
+			      be16_to_cpu(tlv_hdr->totallen), dev_num);
+	if (ret < 0)
+		return ret;
+	if (!tlvinfo_check_crc(eeprom))
+		return -EINVAL;
+
+	*hdr = tlv_hdr;
+	*first_entry = tlv_ent;
+
+	return 0;
+}
+
+/**
+ *  mac_read_from_eeprom
+ *
+ *  Read the MAC addresses from EEPROM
+ *
+ *  This function reads the MAC addresses from EEPROM and sets the
+ *  appropriate environment variables for each one read.
+ *
+ *  The environment variables are only set if they haven't been set already.
+ *  This ensures that any user-saved variables are never overwritten.
+ *
+ *  This function must be called after relocation.
+ */
+int mac_read_from_eeprom(void)
+{
+	unsigned int i;
+	int eeprom_index;
+	struct tlvinfo_tlv *eeprom_tlv;
+	int maccount;
+	u8 macbase[6];
+	struct tlvinfo_header *eeprom_hdr = to_header(eeprom);
+	int devnum = 0; // TODO: support multiple EEPROMs
+
+	puts("EEPROM: ");
+
+	if (read_eeprom(devnum, eeprom)) {
+		printf("Read failed.\n");
+		return -1;
+	}
+
+	maccount = 1;
+	if (tlvinfo_find_tlv(eeprom, TLV_CODE_MAC_SIZE, &eeprom_index)) {
+		eeprom_tlv = to_entry(&eeprom[eeprom_index]);
+		maccount = (eeprom_tlv->value[0] << 8) | eeprom_tlv->value[1];
+	}
+
+	memcpy(macbase, "\0\0\0\0\0\0", 6);
+	if (tlvinfo_find_tlv(eeprom, TLV_CODE_MAC_BASE, &eeprom_index)) {
+		eeprom_tlv = to_entry(&eeprom[eeprom_index]);
+		memcpy(macbase, eeprom_tlv->value, 6);
+	}
+
+	for (i = 0; i < maccount; i++) {
+		if (is_valid_ethaddr(macbase)) {
+			char ethaddr[18];
+			char enetvar[11];
+
+			sprintf(ethaddr, "%02X:%02X:%02X:%02X:%02X:%02X",
+				macbase[0], macbase[1], macbase[2],
+				macbase[3], macbase[4], macbase[5]);
+			sprintf(enetvar, i ? "eth%daddr" : "ethaddr", i);
+			/* Only initialize environment variables that are blank
+			 * (i.e. have not yet been set)
+			 */
+			if (!env_get(enetvar))
+				env_set(enetvar, ethaddr);
+
+			macbase[5]++;
+			if (macbase[5] == 0) {
+				macbase[4]++;
+				if (macbase[4] == 0) {
+					macbase[3]++;
+					if (macbase[3] == 0) {
+						macbase[0] = 0;
+						macbase[1] = 0;
+						macbase[2] = 0;
+					}
+				}
+			}
+		}
+	}
+
+	printf("%s v%u len=%u\n", eeprom_hdr->signature, eeprom_hdr->version,
+	       be16_to_cpu(eeprom_hdr->totallen));
+
+	return 0;
+}
+
+/**
+ *  populate_serial_number - read the serial number from EEPROM
+ *
+ *  This function reads the serial number from the EEPROM and sets the
+ *  appropriate environment variable.
+ *
+ *  The environment variable is only set if it has not been set
+ *  already.  This ensures that any user-saved variables are never
+ *  overwritten.
+ *
+ *  This function must be called after relocation.
+ */
+int populate_serial_number(int devnum)
+{
+	char serialstr[257];
+	int eeprom_index;
+	struct tlvinfo_tlv *eeprom_tlv;
+
+	if (env_get("serial#"))
+		return 0;
+
+	if (read_eeprom(devnum, eeprom)) {
+		printf("Read failed.\n");
+		return -1;
+	}
+
+	if (tlvinfo_find_tlv(eeprom, TLV_CODE_SERIAL_NUMBER, &eeprom_index)) {
+		eeprom_tlv = to_entry(&eeprom[eeprom_index]);
+		memcpy(serialstr, eeprom_tlv->value, eeprom_tlv->length);
+		serialstr[eeprom_tlv->length] = 0;
+		env_set("serial#", serialstr);
+	}
+
+	return 0;
+}
